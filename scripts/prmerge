#!/bin/bash
# prmerge - Comprehensive PR merge workflow command
# 
# Usage: prmerge <issue_number> [<actual_hours>]
#
# This command handles the complete PR workflow:
# 1. Validates PR exists and CI passes
# 2. Reviews PR (guides manual review if needed)
# 3. Handles branch protection issues
# 4. Merges PR with squash commit
# 5. Gets merge commit SHA
# 6. Generates comprehensive issue closing message
# 7. Closes issue with detailed documentation
# 8. Records completion for learning system
# 9. Suggests next issue
#
# Multi-repo support:
# - Automatically detects if running in AI-Agent-Framework or AI-Agent-Framework-Client
# - Works with client repo when invoked from backend root (uses _external/ path)
#
# Example:
#   prmerge 24 7.5

set -e

# Detect repository context
detect_repo() {
    local current_dir="$(pwd)"
    
    # Check if we're in the client repo or _external/AI-Agent-Framework-Client
    if [[ "$current_dir" == *"AI-Agent-Framework-Client"* ]]; then
        echo "client"
        return 0
    fi
    
    # Check if _external/AI-Agent-Framework-Client exists (backend invoking client PR)
    if [[ -d "_external/AI-Agent-Framework-Client" ]]; then
        echo "backend-with-client"
        return 0
    fi
    
    # Default to backend
    echo "backend"
}

# Get repository root path
get_repo_path() {
    local repo_type="$1"
    
    case "$repo_type" in
        client)
            echo "$(pwd)"
            ;;
        backend-with-client)
            echo "$(pwd)/_external/AI-Agent-Framework-Client"
            ;;
        backend)
            echo "$(pwd)"
            ;;
    esac
}

# Get GitHub repository name
get_repo_name() {
    local repo_type="$1"
    
    case "$repo_type" in
        client|backend-with-client)
            echo "blecx/AI-Agent-Framework-Client"
            ;;
        backend)
            echo "blecx/AI-Agent-Framework"
            ;;
    esac
}

REPO_TYPE=$(detect_repo)
REPO_PATH=$(get_repo_path "$REPO_TYPE")
REPO_NAME=$(get_repo_name "$REPO_TYPE")

if [[ "$REPO_TYPE" == "backend-with-client" ]]; then
    info "Working with client repository: $REPO_PATH"
fi

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
info() {
    echo -e "${BLUE}‚Ñπ${NC} $1"
}

success() {
    echo -e "${GREEN}‚úÖ${NC} $1"
}

warning() {
    echo -e "${YELLOW}‚ö†Ô∏è${NC} $1"
}

error() {
    echo -e "${RED}‚ùå${NC} $1"
}

section() {
    echo ""
    echo "========================================="
    echo "$1"
    echo "========================================="
    echo ""
}

# Detect issue type for template selection
detect_issue_type() {
    local title="$1"
    local pr_body="$2"
    local files_changed="$3"
    
    # Check title patterns first
    if [[ "$title" =~ (Infrastructure|Setup|Configuration|Foundation|API Service Layer) ]]; then
        echo "infrastructure"
    elif [[ "$title" =~ (fix:|Fix|bug:|Bug|hotfix:|Hotfix) ]]; then
        echo "bugfix"
    elif [[ "$title" =~ (docs:|Docs|documentation|Documentation) ]]; then
        echo "docs"
    else
        # Check file patterns if title is ambiguous
        local doc_count=$(echo "$files_changed" | grep -c '\.md$\|/docs/' || echo "0")
        local test_count=$(echo "$files_changed" | grep -c 'test\|spec' || echo "0")
        local total_files=$(echo "$files_changed" | wc -l)
        
        # If >50% doc files, it's a docs issue
        if [ "$total_files" -gt 0 ] && [ "$doc_count" -gt "$((total_files / 2))" ]; then
            echo "docs"
        else
            echo "feature"  # Default
        fi
    fi
}

# Capture enhanced metrics from PR
capture_pr_metrics() {
    local pr_number="$1"
    local pr_files="$2"
    local pr_additions="$3"
    local pr_deletions="$4"
    
    # Get commit count
    local commits=$(gh pr view "$pr_number" --json commits --jq '.commits | length')
    
    # Calculate complexity score
    local complexity="low"
    if [ "$pr_files" -ge 10 ]; then
        complexity="high"
    elif [ "$pr_files" -ge 5 ]; then
        complexity="medium"
    fi
    
    # Calculate test ratio (approximate)
    local test_files=$(gh pr view "$pr_number" --json files --jq '[.files[] | select(.path | test("test|spec"))] | length')
    local test_ratio="0.0"
    if [ "$pr_files" -gt 0 ]; then
        test_ratio=$(awk "BEGIN {printf \"%.2f\", $test_files / $pr_files}")
    fi
    
    # Get CI run count
    local ci_runs=$(gh run list --branch "$(gh pr view "$pr_number" --json headRefName --jq '.headRefName')" --limit 20 --json conclusion --jq 'length')
    local ci_iterations="$ci_runs"
    
    # Store metrics in temporary file for later use (workspace-scoped)
    mkdir -p .tmp
    cat > .tmp/prmerge-metrics-$pr_number.json << EOF
{
  "pr_metrics": {
    "files_changed": $pr_files,
    "additions": $pr_additions,
    "deletions": $pr_deletions,
    "commits": $commits,
    "complexity_score": "$complexity",
    "test_ratio": $test_ratio
  },
  "workflow_metrics": {
    "ci_iterations": $ci_iterations
  }
}
EOF
    
    echo "complexity=$complexity,commits=$commits,test_ratio=$test_ratio,ci_iterations=$ci_iterations"
}

# Validate PR description follows template
validate_pr_template() {
    local pr_body="$1"
    local pr_number="$2"
    
    info "Validating PR description format..."
    
    local required_sections=(
        "# Summary"
        "## Goal / Acceptance Criteria (required)"
        "## Issue / Tracking Link (required)"
        "## Validation (required)"
        "## Automated checks"
        "## Manual test evidence (required)"
    )
    
    local missing_sections=()
    local warnings=()
    
    # Check for required sections
    for section in "${required_sections[@]}"; do
        if ! echo "$pr_body" | grep -q "$section"; then
            missing_sections+=("$section")
        fi
    done
    
    # Check if Fixes: line exists (accepts #N or owner/repo#N format)
    if ! echo "$pr_body" | grep -Eq "^Fixes: (#[0-9]+|[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+#[0-9]+)"; then
        warnings+=("Missing 'Fixes: #<issue>' or 'Fixes: owner/repo#<issue>' line")
    fi
    
    # Check if acceptance criteria have checkboxes
    local ac_section=$(echo "$pr_body" | sed -n '/## Goal \/ Acceptance Criteria/,/##/p')
    if [ -n "$ac_section" ]; then
        if ! echo "$ac_section" | grep -q "\[x\]\|\[X\]"; then
            warnings+=("Acceptance criteria checkboxes not checked")
        fi
    fi
    
    # Check if automated checks are filled
    if echo "$pr_body" | grep -q "## Automated checks"; then
        local auto_section=$(echo "$pr_body" | sed -n '/## Automated checks/,/## Manual test/p')
        if echo "$auto_section" | grep -Eq "Evidence.*:$|Evidence.*: *$"; then
            warnings+=("Automated checks evidence appears empty (inline format required)")
        fi
    fi
    
    # Report results
    if [ ${#missing_sections[@]} -gt 0 ]; then
        error "PR template validation FAILED - Missing required sections:"
        for section in "${missing_sections[@]}"; do
            echo "  ‚ùå $section"
        done
        return 1
    fi
    
    if [ ${#warnings[@]} -gt 0 ]; then
        warning "PR template validation WARNINGS:"
        for warn in "${warnings[@]}"; do
            echo "  ‚ö†Ô∏è  $warn"
        done
        echo ""
        read -p "Continue despite warnings? (y/N): " continue_despite_warnings
        if [[ ! "$continue_despite_warnings" =~ ^[Yy]$ ]]; then
            info "Merge cancelled. Please fix PR description and re-run prmerge."
            return 1
        fi
    fi
    
    success "PR template validation passed"
    return 0
}

# Generate infrastructure template
generate_infrastructure_template() {
    local pr_number="$1"
    local pr_url="$2"
    local commit_sha="$3"
    local pr_title="$4"
    local acceptance_criteria="$5"
    local pr_files="$6"
    local pr_additions="$7"
    local pr_deletions="$8"
    local issue_number="$9"
    local metrics="${10}"
    
    cat << EOF
‚úÖ **INFRASTRUCTURE COMPLETE** in PR #$pr_number

**Merge Commit:** \`$commit_sha\`
**PR URL:** $pr_url

## Setup Complete

$pr_title

## Acceptance Criteria

$acceptance_criteria

## Components Added

**Files:** $pr_files files changed
**Lines:** +$pr_additions / -$pr_deletions
**Complexity:** $(echo "$metrics" | cut -d',' -f1 | cut -d'=' -f2)
**Commits:** $(echo "$metrics" | cut -d',' -f2 | cut -d'=' -f2)

## Testing

**CI Status:**
- ‚úÖ Build: Passing
- ‚úÖ Lint: Passing  
- ‚úÖ Tests: Passing
- ‚úÖ Type Check: Passing

**CI Iterations:** $(echo "$metrics" | cut -d',' -f4 | cut -d'=' -f2)
**Test Coverage:** Test ratio $(echo "$metrics" | cut -d',' -f3 | cut -d'=' -f2)

## Documentation

See PR #$pr_number for complete implementation details and file-by-file changes.

## Next Steps

Run \`./next-pr\` to find the next mergeable PR.

---

**Status:** ‚úÖ Complete | üöÄ Ready for next issue
**Completed:** $(date +"%Y-%m-%d %H:%M:%S")
EOF
}

# Generate feature template
generate_feature_template() {
    local pr_number="$1"
    local pr_url="$2"
    local commit_sha="$3"
    local pr_title="$4"
    local acceptance_criteria="$5"
    local pr_files="$6"
    local pr_additions="$7"
    local pr_deletions="$8"
    local issue_number="$9"
    local metrics="${10}"
    
    cat << EOF
‚úÖ **FEATURE COMPLETE** in PR #$pr_number

**Merge Commit:** \`$commit_sha\`
**PR URL:** $pr_url

## Feature Summary

$pr_title

## Acceptance Criteria

$acceptance_criteria

## Implementation

**Files:** $pr_files files changed (+$pr_additions / -$pr_deletions)
**Complexity:** $(echo "$metrics" | cut -d',' -f1 | cut -d'=' -f2)
**Commits:** $(echo "$metrics" | cut -d',' -f2 | cut -d'=' -f2)

## Testing

**CI Status:**
- ‚úÖ Build: Passing
- ‚úÖ Lint: Passing
- ‚úÖ Tests: Passing
- ‚úÖ Type Check: Passing

**Test Coverage:** Test ratio $(echo "$metrics" | cut -d',' -f3 | cut -d'=' -f2)
**CI Iterations:** $(echo "$metrics" | cut -d',' -f4 | cut -d'=' -f2)

## Documentation

See PR #$pr_number for complete details and file-by-file changes.

## Next Steps

Run \`./next-pr\` to find the next mergeable PR.

---

**Status:** ‚úÖ Complete | üöÄ Ready for next issue
**Completed:** $(date +"%Y-%m-%d %H:%M:%S")
EOF
}

# Generate bugfix template
generate_bugfix_template() {
    local pr_number="$1"
    local pr_url="$2"
    local commit_sha="$3"
    local pr_title="$4"
    local acceptance_criteria="$5"
    local pr_files="$6"
    local pr_additions="$7"
    local pr_deletions="$8"
    local issue_number="$9"
    local metrics="${10}"
    
    cat << EOF
‚úÖ **BUGFIX COMPLETE** in PR #$pr_number

**Merge Commit:** \`$commit_sha\`
**PR URL:** $pr_url

## Bug Fixed

$pr_title

## Solution

$acceptance_criteria

## Changes

**Files:** $pr_files files changed (+$pr_additions / -$pr_deletions)
**Commits:** $(echo "$metrics" | cut -d',' -f2 | cut -d'=' -f2)

## Testing

**CI Status:**
- ‚úÖ Build: Passing
- ‚úÖ Lint: Passing  
- ‚úÖ Tests: Passing (including regression tests)
- ‚úÖ Type Check: Passing

**Test Coverage:** Test ratio $(echo "$metrics" | cut -d',' -f3 | cut -d'=' -f2)
**CI Iterations:** $(echo "$metrics" | cut -d',' -f4 | cut -d'=' -f2)

## Verification

See PR #$pr_number for detailed verification steps and test results.

---

**Status:** ‚úÖ Complete | üöÄ Verified
**Completed:** $(date +"%Y-%m-%d %H:%M:%S")
EOF
}

# Generate documentation template
generate_docs_template() {
    local pr_number="$1"
    local pr_url="$2"
    local commit_sha="$3"
    local pr_title="$4"
    local acceptance_criteria="$5"
    local pr_files="$6"
    local pr_additions="$7"
    local pr_deletions="$8"
    local issue_number="$9"
    local metrics="${10}"
    
    cat << EOF
‚úÖ **DOCUMENTATION COMPLETE** in PR #$pr_number

**Merge Commit:** \`$commit_sha\`
**PR URL:** $pr_url

## Documentation Added

$pr_title

## Content

$acceptance_criteria

## Files Updated

**Documentation Files:** $pr_files files
**Lines:** +$pr_additions / -$pr_deletions
**Commits:** $(echo "$metrics" | cut -d',' -f2 | cut -d'=' -f2)

## Review

- ‚úÖ Technical Accuracy: Verified
- ‚úÖ Clarity: Reviewed
- ‚úÖ Completeness: Validated
- ‚úÖ Examples: Included

## Documentation

View complete documentation in PR #$pr_number.

---

**Status:** ‚úÖ Complete | üìñ Published
**Completed:** $(date +"%Y-%m-%d %H:%M:%S")
EOF
}

# Check arguments
if [ $# -lt 1 ]; then
    error "Usage: prmerge <issue_number> [<actual_hours>]"
    echo ""
    echo "Examples:"
    echo "  prmerge 24"
    echo "  prmerge 24 7.5"
    exit 1
fi

ISSUE_NUMBER=$1
ACTUAL_HOURS=${2:-""}

# Determine repository root and working directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Check if we're in main repo or client repo
if [ -f "$REPO_ROOT/_external/AI-Agent-Framework-Client/package.json" ]; then
    # We're in main repo, work with client
    CLIENT_REPO="$REPO_ROOT/_external/AI-Agent-Framework-Client"
    MAIN_REPO="$REPO_ROOT"
    info "Working with client repository: $CLIENT_REPO"
elif [ -f "$REPO_ROOT/package.json" ]; then
    # We're already in client repo
    CLIENT_REPO="$REPO_ROOT"
    MAIN_REPO="$(cd "$REPO_ROOT/../.." && pwd)"
    info "Working in client repository"
else
    error "Cannot determine repository structure"
    exit 1
fi

cd "$CLIENT_REPO"

section "Step 1: Validate PR and CI Status"

# Find PR number for this issue
info "Finding PR for Issue #$ISSUE_NUMBER..."
PR_NUMBER=$(gh pr list --search "issue #$ISSUE_NUMBER in:title" --state all --json number --jq '.[0].number' 2>/dev/null || echo "")

if [ -z "$PR_NUMBER" ]; then
    error "No PR found for Issue #$ISSUE_NUMBER"
    info "Attempting alternate search pattern..."
    PR_NUMBER=$(gh pr list --search "$ISSUE_NUMBER" --state all --json number,title --jq ".[] | select(.title | contains(\"#$ISSUE_NUMBER\") or contains(\"Issue $ISSUE_NUMBER\")) | .number" | head -1)
    
    if [ -z "$PR_NUMBER" ]; then
        error "Could not find PR. Please specify PR number manually:"
        read -p "Enter PR number: " PR_NUMBER
        if [ -z "$PR_NUMBER" ]; then
            error "PR number required"
            exit 1
        fi
    fi
fi

success "Found PR #$PR_NUMBER"

# Get PR details
info "Checking PR status..."
PR_JSON=$(gh pr view "$PR_NUMBER" --json number,title,state,mergeable,mergeStateStatus,statusCheckRollup,headRefName,url)
PR_STATE=$(echo "$PR_JSON" | jq -r '.state')
PR_TITLE=$(echo "$PR_JSON" | jq -r '.title')
PR_MERGEABLE=$(echo "$PR_JSON" | jq -r '.mergeable')
PR_MERGE_STATE=$(echo "$PR_JSON" | jq -r '.mergeStateStatus')
PR_BRANCH=$(echo "$PR_JSON" | jq -r '.headRefName')
PR_URL=$(echo "$PR_JSON" | jq -r '.url')

echo ""
echo "PR Details:"
echo "  Number: #$PR_NUMBER"
echo "  Title: $PR_TITLE"
echo "  State: $PR_STATE"
echo "  Branch: $PR_BRANCH"
echo "  URL: $PR_URL"
echo ""

# Check if already merged
if [ "$PR_STATE" = "MERGED" ]; then
    success "PR #$PR_NUMBER is already merged!"
    
    # Get merge commit
    MERGE_COMMIT=$(gh pr view "$PR_NUMBER" --json mergeCommit --jq '.mergeCommit.oid')
    MERGE_COMMIT_SHORT="${MERGE_COMMIT:0:7}"
    
    info "Merge commit: $MERGE_COMMIT_SHORT"
    
    # Check if issue is closed
    ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state')
    
    if [ "$ISSUE_STATE" = "CLOSED" ]; then
        success "Issue #$ISSUE_NUMBER is already closed"
        
        if [ -n "$ACTUAL_HOURS" ]; then
            info "Recording completion time..."
            cd "$MAIN_REPO"
            ./scripts/record-completion.py "$ISSUE_NUMBER" "$ACTUAL_HOURS" "Completed via prmerge script"
            success "Completion recorded"
        else
            warning "Completion time not recorded. Run: ./scripts/record-completion.py $ISSUE_NUMBER <hours> '<notes>'"
        fi
        
        info "Run './next-pr' to find the next mergeable PR"
        exit 0
    else
        warning "Issue #$ISSUE_NUMBER is still open. Proceeding to close..."
        # Continue to issue closing section
    fi
else
    # PR not yet merged, check CI status
    info "Checking CI status..."
    CI_STATUS=$(echo "$PR_JSON" | jq -r '.statusCheckRollup[]? | select(.conclusion != null) | .conclusion' | sort -u)
    
    if echo "$CI_STATUS" | grep -q "FAILURE\|CANCELLED"; then
        error "CI checks are failing! Cannot merge."
        echo ""
        echo "Failed checks:"
        echo "$PR_JSON" | jq -r '.statusCheckRollup[]? | select(.conclusion == "FAILURE" or .conclusion == "CANCELLED") | "  - \(.name): \(.conclusion)"'
        echo ""
        warning "Please fix CI failures before merging"
        warning "PR URL: $PR_URL"
        exit 1
    fi
    
    if echo "$CI_STATUS" | grep -q "SUCCESS"; then
        success "All CI checks passing"
    else
        warning "CI status unclear or pending"
        read -p "Continue anyway? (y/N): " continue_merge
        if [[ ! "$continue_merge" =~ ^[Yy]$ ]]; then
            info "Merge cancelled"
            exit 0
        fi
    fi
    
    # Validate PR template
    info "Validating PR description format..."
    PR_BODY=$(gh pr view "$PR_NUMBER" --json body --jq '.body')
    if ! validate_pr_template "$PR_BODY" "$PR_NUMBER"; then
        error "PR template validation failed. Please fix the PR description."
        warning "PR URL: $PR_URL"
        exit 1
    fi
    
    section "Step 2: Review PR"
    
    info "Opening PR in browser for review..."
    if command -v xdg-open &> /dev/null; then
        xdg-open "$PR_URL" &> /dev/null || true
    elif command -v open &> /dev/null; then
        open "$PR_URL" &> /dev/null || true
    fi
    
    echo ""
    echo "Please review the PR:"
    echo "  - Check code quality and architecture"
    echo "  - Verify tests are comprehensive"
    echo "  - Ensure documentation is complete"
    echo "  - Validate acceptance criteria are met"
    echo ""
    
    read -p "Has the PR been reviewed and approved? (y/N): " pr_approved
    if [[ ! "$pr_approved" =~ ^[Yy]$ ]]; then
        info "Please complete review before merging"
        exit 0
    fi
    
    section "Step 3: Merge PR"
    
    # Check if branch protection requires approval
    if [ "$PR_MERGE_STATE" = "BLOCKED" ]; then
        warning "PR is blocked by branch protection"
        echo ""
        echo "Options to unblock:"
        echo "  A) Approve via GitHub UI: $PR_URL"
        echo "  B) Temporarily disable branch protection"
        echo "  C) Manual git merge (bypass GitHub PR)"
        echo ""
        read -p "Which option? (A/B/C): " unblock_option
        
        case "${unblock_option^^}" in
            A)
                info "Please approve the PR at: $PR_URL"
                read -p "Press Enter after approving..."
                ;;
            B)
                warning "Temporarily disabling branch protection"
                warning "Remember to re-enable it after merge!"
                read -p "Press Enter after disabling protection..."
                ;;
            C)
                info "Performing manual git merge..."
                git fetch origin
                git checkout main
                git pull origin main
                git merge --squash "origin/$PR_BRANCH"
                git commit -m "[$PR_TITLE]"
                git push origin main
                
                # Close PR manually
                gh pr close "$PR_NUMBER" --comment "Merged manually via git"
                
                success "Manual merge complete"
                MERGE_COMMIT=$(git log -1 --format="%H")
                MERGE_COMMIT_SHORT="${MERGE_COMMIT:0:7}"
                
                # Continue to issue closing
                ;;
            *)
                error "Invalid option"
                exit 1
                ;;
        esac
    fi
    
    # Attempt merge if not manually merged
    if [ "$PR_STATE" != "MERGED" ]; then
        info "Attempting to merge PR #$PR_NUMBER..."
        
        # Try merge with squash
        if gh pr merge "$PR_NUMBER" --squash --delete-branch 2>&1; then
            success "PR merged successfully!"
        else
            error "Merge failed. Trying with --admin flag..."
            
            if gh pr merge "$PR_NUMBER" --squash --delete-branch --admin 2>&1; then
                success "PR merged with admin override!"
            else
                error "Merge failed even with admin flag"
                error "Please merge manually at: $PR_URL"
                exit 1
            fi
        fi
        
        # Get merge commit
        sleep 2  # Wait for GitHub to process merge
        MERGE_COMMIT=$(gh pr view "$PR_NUMBER" --json mergeCommit --jq '.mergeCommit.oid')
        MERGE_COMMIT_SHORT="${MERGE_COMMIT:0:7}"
        
        success "Merge commit: $MERGE_COMMIT_SHORT"
    fi
fi

section "Step 4: Generate Issue Closing Message"

# Pull latest changes
git checkout main 2>/dev/null || true
git pull origin main

info "Analyzing PR changes..."

# Get PR details for closing message
PR_FILES=$(gh pr view "$PR_NUMBER" --json files --jq '.files | length')
PR_ADDITIONS=$(gh pr view "$PR_NUMBER" --json additions --jq '.additions')
PR_DELETIONS=$(gh pr view "$PR_NUMBER" --json deletions --jq '.deletions')
PR_BODY=$(gh pr view "$PR_NUMBER" --json body --jq '.body')
PR_FILES_LIST=$(gh pr view "$PR_NUMBER" --json files --jq '.files[].path')

# Extract acceptance criteria from PR body
ACCEPTANCE_CRITERIA=$(echo "$PR_BODY" | sed -n '/## Goal \/ Acceptance Criteria/,/##/p' | grep -E '^\s*[-*]' | sed 's/^/- ‚úÖ /' || echo "")

if [ -z "$ACCEPTANCE_CRITERIA" ]; then
    warning "Could not extract acceptance criteria from PR body"
    ACCEPTANCE_CRITERIA="- ‚úÖ All requirements met per Issue #$ISSUE_NUMBER"
fi

# Capture enhanced metrics
info "Capturing PR metrics..."
METRICS=$(capture_pr_metrics "$PR_NUMBER" "$PR_FILES" "$PR_ADDITIONS" "$PR_DELETIONS")
info "Metrics: $METRICS"

# Detect issue type
info "Detecting issue type..."
ISSUE_TYPE=$(detect_issue_type "$PR_TITLE" "$PR_BODY" "$PR_FILES_LIST")
success "Detected type: $ISSUE_TYPE"

# Create closing message using appropriate template
CLOSING_MESSAGE_FILE=$(mktemp)

case "$ISSUE_TYPE" in
    infrastructure)
        generate_infrastructure_template "$PR_NUMBER" "$PR_URL" "$MERGE_COMMIT_SHORT" "$PR_TITLE" "$ACCEPTANCE_CRITERIA" "$PR_FILES" "$PR_ADDITIONS" "$PR_DELETIONS" "$ISSUE_NUMBER" "$METRICS" > "$CLOSING_MESSAGE_FILE"
        ;;
    bugfix)
        generate_bugfix_template "$PR_NUMBER" "$PR_URL" "$MERGE_COMMIT_SHORT" "$PR_TITLE" "$ACCEPTANCE_CRITERIA" "$PR_FILES" "$PR_ADDITIONS" "$PR_DELETIONS" "$ISSUE_NUMBER" "$METRICS" > "$CLOSING_MESSAGE_FILE"
        ;;
    docs)
        generate_docs_template "$PR_NUMBER" "$PR_URL" "$MERGE_COMMIT_SHORT" "$PR_TITLE" "$ACCEPTANCE_CRITERIA" "$PR_FILES" "$PR_ADDITIONS" "$PR_DELETIONS" "$ISSUE_NUMBER" "$METRICS" > "$CLOSING_MESSAGE_FILE"
        ;;
    feature|*)
        generate_feature_template "$PR_NUMBER" "$PR_URL" "$MERGE_COMMIT_SHORT" "$PR_TITLE" "$ACCEPTANCE_CRITERIA" "$PR_FILES" "$PR_ADDITIONS" "$PR_DELETIONS" "$ISSUE_NUMBER" "$METRICS" > "$CLOSING_MESSAGE_FILE"
        ;;
esac

success "Generated $ISSUE_TYPE closing message with enhanced metrics"

section "Step 5: Close Issue"

# Check if issue exists and is open
ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state' 2>/dev/null || echo "NOTFOUND")

if [ "$ISSUE_STATE" = "NOTFOUND" ]; then
    error "Issue #$ISSUE_NUMBER not found"
    exit 1
elif [ "$ISSUE_STATE" = "CLOSED" ]; then
    success "Issue #$ISSUE_NUMBER is already closed"
else
    info "Closing Issue #$ISSUE_NUMBER..."
    
    if gh issue close "$ISSUE_NUMBER" --comment "$(cat "$CLOSING_MESSAGE_FILE")"; then
        success "Issue #$ISSUE_NUMBER closed with comprehensive message"
    else
        error "Failed to close issue"
        warning "Closing message saved to: $CLOSING_MESSAGE_FILE"
        exit 1
    fi
fi

# Clean up temp file
rm -f "$CLOSING_MESSAGE_FILE"

section "Step 6: Record Completion"

cd "$MAIN_REPO"

if [ -n "$ACTUAL_HOURS" ]; then
    info "Recording completion time: $ACTUAL_HOURS hours"
    
    # Optional learning prompts (can be skipped)
    echo ""
    info "Optional: Provide learning data for future estimates (press Enter to skip)"
    read -p "Unexpected challenges encountered (optional): " CHALLENGES
    read -p "Main time sink if any (optional): " TIME_SINK
    read -p "Key learning/insight (optional): " LEARNING
    
    # Build notes string
    NOTES="Completed via prmerge - Merge: $MERGE_COMMIT_SHORT"
    if [ -n "$CHALLENGES" ]; then
        NOTES="$NOTES | Challenges: $CHALLENGES"
    fi
    if [ -n "$TIME_SINK" ]; then
        NOTES="$NOTES | Time sink: $TIME_SINK"
    fi
    if [ -n "$LEARNING" ]; then
        NOTES="$NOTES | Learning: $LEARNING"
    fi
    
    # Add metrics to notes
    if [ -f ".tmp/prmerge-metrics-$PR_NUMBER.json" ]; then
        NOTES="$NOTES | Metrics: $(cat .tmp/prmerge-metrics-$PR_NUMBER.json)"
        rm -f ".tmp/prmerge-metrics-$PR_NUMBER.json"
    fi
    
    if [ -f "./scripts/record-completion.py" ]; then
        ./scripts/record-completion.py "$ISSUE_NUMBER" "$ACTUAL_HOURS" "$NOTES"
        success "Completion recorded in learning system with enhanced metrics"
    else
        warning "record-completion.py not found, skipping"
    fi
else
    warning "Actual hours not provided, skipping completion recording"
    info "To record later: ./scripts/record-completion.py $ISSUE_NUMBER <hours> '<notes>'"
fi

section "Step 7: Verification and Summary"

# Verify PR is merged
info "Verifying PR merge status..."
FINAL_PR_STATE=$(gh pr view "$PR_NUMBER" --json state --jq '.state')
if [ "$FINAL_PR_STATE" != "MERGED" ]; then
    error "PR #$PR_NUMBER is not in MERGED state (current: $FINAL_PR_STATE)"
    exit 1
fi
success "‚úì PR #$PR_NUMBER is MERGED"

# Verify issue is closed
info "Verifying issue closure..."
FINAL_ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state,closedAt --jq '.state')
ISSUE_CLOSED_AT=$(gh issue view "$ISSUE_NUMBER" --json closedAt --jq '.closedAt')
if [ "$FINAL_ISSUE_STATE" != "CLOSED" ]; then
    error "Issue #$ISSUE_NUMBER is not CLOSED (current: $FINAL_ISSUE_STATE)"
    exit 1
fi
success "‚úì Issue #$ISSUE_NUMBER is CLOSED (at $ISSUE_CLOSED_AT)"

# Verify issue has closing comment
info "Verifying issue closing message..."
ISSUE_COMMENTS=$(gh issue view "$ISSUE_NUMBER" --json comments --jq '.comments | length')
if [ "$ISSUE_COMMENTS" -eq 0 ]; then
    warning "Issue has no comments (closing message may be missing)"
else
    LAST_COMMENT=$(gh issue view "$ISSUE_NUMBER" --json comments --jq '.comments[-1].body')
    if echo "$LAST_COMMENT" | grep -q "COMPLETE\|PR #$PR_NUMBER"; then
        success "‚úì Comprehensive closing message posted"
    else
        warning "Last comment may not be the closing message"
    fi
fi

success "All verifications passed!"
echo ""

success "PR Merge Workflow Complete!"
echo ""
echo "Summary:"
echo "  - Issue Type: $ISSUE_TYPE"
echo "  - PR #$PR_NUMBER merged: $PR_URL"
echo "  - Merge commit: $MERGE_COMMIT_SHORT"
echo "  - Issue #$ISSUE_NUMBER closed with $ISSUE_TYPE template"
echo "  - Files changed: $PR_FILES (+$PR_ADDITIONS/-$PR_DELETIONS)"
echo "  - Complexity: $(echo "$METRICS" | cut -d',' -f1 | cut -d'=' -f2)"
echo "  - CI iterations: $(echo "$METRICS" | cut -d',' -f4 | cut -d'=' -f2)"
if [ -n "$ACTUAL_HOURS" ]; then
    echo "  - Completion recorded: $ACTUAL_HOURS hours with enhanced metrics"
fi
echo ""

# Display lessons learned from Issue #25 (if applicable)
if [ "$ISSUE_NUMBER" = "25" ] || [ "$ISSUE_TYPE" = "infrastructure" ]; then
    section "Lessons Learned (Issue #25 Pattern)"
    echo "Key insights from routing infrastructure implementation:"
    echo ""
    echo "What worked well:"
    echo "  ‚úÖ Detailed planning document saved 1-2 hours implementation time"
    echo "  ‚úÖ Test-first approach caught issues early (12 tests written alongside code)"
    echo "  ‚úÖ Self-review caught critical mistakes before user review (MANDATORY gate)"
    echo "  ‚úÖ Copilot review improved UX (layout consistency fixes)"
    echo "  ‚úÖ Phase commits enabled clear progress tracking and easy rollback"
    echo ""
    echo "PR template lessons:"
    echo "  ‚ö†Ô∏è  Evidence format matters: Inline summaries required, not code blocks"
    echo "  ‚ö†Ô∏è  CI validation strict: All checkboxes must be checked, no placeholders"
    echo "  ‚ö†Ô∏è  Fix PR description BEFORE push to avoid CI re-runs"
    echo ""
    echo "Process improvements:"
    echo "  üìù Always create docs/issues/issue-N-context.md in Phase 2"
    echo "  üìù Never remove existing features without user confirmation"
    echo "  üìù Verify everything with actual command output (no assumptions)"
    echo "  üìù Build frequently during development, not just at end"
    echo ""
fi

echo "Next steps:"
echo "  1. Run './next-pr' to find the next mergeable PR"
echo "  2. Review PR diffs + CI evidence"
echo "  3. Merge (squash) when ready"
echo ""

# Offer to run next-pr
read -p "Run './next-pr' now? (Y/n): " run_next_pr
if [[ ! "$run_next_pr" =~ ^[Nn]$ ]]; then
    echo ""
    if [ -f "./scripts/next-pr.py" ]; then
        ./scripts/next-pr.py
    else
        warning "next-pr.py not found"
        info "Please run manually: cd $MAIN_REPO && ./scripts/next-pr.py"
    fi
fi

success "All done! üöÄ"
