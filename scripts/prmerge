#!/bin/bash
# prmerge - Comprehensive PR merge workflow command
# 
# Usage: prmerge <issue_number> [<actual_hours>]
#
# This command handles the complete PR workflow:
# 1. Validates PR exists and CI passes
# 2. Reviews PR (guides manual review if needed)
# 3. Handles branch protection issues
# 4. Merges PR with squash commit
# 5. Gets merge commit SHA
# 6. Generates comprehensive issue closing message
# 7. Closes issue with detailed documentation
# 8. Records completion for learning system
# 9. Suggests next issue
#
# Multi-repo support:
# - Automatically detects if running in AI-Agent-Framework or AI-Agent-Framework-Client
# - Works with client repo when invoked from backend root (uses sibling repo path)
#
# Example:
#   prmerge 24 7.5

set -e

# Color codes for output (must be defined before helper functions use them)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Merge policy defaults (override via environment if needed)
PRMERGE_MAX_FILES=${PRMERGE_MAX_FILES:-12}
PRMERGE_MAX_LINES=${PRMERGE_MAX_LINES:-500}
PRMERGE_ALLOW_LARGE_SLICE=${PRMERGE_ALLOW_LARGE_SLICE:-0}
PRMERGE_ALLOW_UNAPPROVED=${PRMERGE_ALLOW_UNAPPROVED:-0}
PRMERGE_ALLOW_WORKFLOW_FILES=${PRMERGE_ALLOW_WORKFLOW_FILES:-0}
PRMERGE_CI_WAIT_TIMEOUT_SECONDS=${PRMERGE_CI_WAIT_TIMEOUT_SECONDS:-1200}
PRMERGE_CI_WATCH_INTERVAL_SECONDS=${PRMERGE_CI_WATCH_INTERVAL_SECONDS:-15}
PRMERGE_LONGRUNNER_MAX_MINUTES=${PRMERGE_LONGRUNNER_MAX_MINUTES:-25}
PRMERGE_CANCEL_LONGRUNNERS=${PRMERGE_CANCEL_LONGRUNNERS:-1}
PRMERGE_ALLOW_NO_REQUIRED_CHECKS=${PRMERGE_ALLOW_NO_REQUIRED_CHECKS:-0}
PRMERGE_GH_MIN_INTERVAL_SECONDS=${PRMERGE_GH_MIN_INTERVAL_SECONDS:-1}
__PRMERGE_GH_LAST_CALL_TS=""

gh() {
    local min_interval
    min_interval="${PRMERGE_GH_MIN_INTERVAL_SECONDS:-0}"

    if [ -n "$__PRMERGE_GH_LAST_CALL_TS" ] && [ "$min_interval" != "0" ]; then
        local now elapsed
        now=$(date +%s)
        elapsed=$((now - __PRMERGE_GH_LAST_CALL_TS))
        if [ "$elapsed" -lt "$min_interval" ]; then
            sleep $((min_interval - elapsed))
        fi
    fi

    command gh "$@"
    __PRMERGE_GH_LAST_CALL_TS=$(date +%s)
}

# Helper functions (must be defined before first use)
info() {
    echo -e "${BLUE}‚Ñπ${NC} $1"
}

success() {
    echo -e "${GREEN}‚úÖ${NC} $1"
}

warning() {
    echo -e "${YELLOW}‚ö†Ô∏è${NC} $1"
}

error() {
    echo -e "${RED}‚ùå${NC} $1"
}

section() {
    echo ""
    echo "========================================="
    echo "$1"
    echo "========================================="
    echo ""
}

cancel_long_running_branch_runs() {
    local branch="$1"
    local max_minutes="$2"

    local now_epoch
    now_epoch=$(date -u +%s)
    local max_age_seconds=$((max_minutes * 60))

    local runs_json
    runs_json=$(gh run list --branch "$branch" --status in_progress --limit 50 --json databaseId,workflowName,createdAt,url 2>/dev/null || echo "[]")

    mapfile -t stale_runs < <(
        echo "$runs_json" | jq -r \
            --argjson now "$now_epoch" \
            --argjson max_age "$max_age_seconds" \
            '.[]
             | . as $run
             | ($now - (.createdAt | fromdateiso8601)) as $age
             | select($age > $max_age)
             | "\($run.databaseId)|\($run.workflowName)|\($run.createdAt)|\($run.url)|\($age)"'
    )

    if [ ${#stale_runs[@]} -eq 0 ]; then
        info "Watchdog: no stale in-progress runs found for branch '$branch'"
        return 0
    fi

    warning "Watchdog: found ${#stale_runs[@]} stale in-progress run(s) older than ${max_minutes}m"
    local cancelled=0
    for stale in "${stale_runs[@]}"; do
        IFS='|' read -r run_id workflow_name created_at run_url age_seconds <<< "$stale"
        local age_minutes=$((age_seconds / 60))
        warning "Cancelling run $run_id ($workflow_name), age=${age_minutes}m, url=$run_url"
        if gh run cancel "$run_id" >/dev/null 2>&1; then
            cancelled=$((cancelled + 1))
        fi
    done

    if [ "$cancelled" -gt 0 ]; then
        success "Watchdog cancelled $cancelled stale run(s)"
    fi

    return 0
}

wait_for_required_ci_checks() {
    local pr_number="$1"
    local branch="$2"

    print_required_ci_summary() {
        local checks_json="$1"

        local now_epoch
        now_epoch=$(date -u +%s)

        local total pass fail pending skipped
        total=$(echo "$checks_json" | jq 'length')
        pass=$(echo "$checks_json" | jq '[.[] | select(.state == "PASS")] | length')
        fail=$(echo "$checks_json" | jq '[.[] | select(.state == "FAIL" or .state == "ERROR" or .state == "CANCEL" or .state == "ACTION_REQUIRED")] | length')
        pending=$(echo "$checks_json" | jq '[.[] | select(.state == "PENDING" or .state == "STARTUP")] | length')
        skipped=$(echo "$checks_json" | jq '[.[] | select(.state == "SKIP")] | length')

        local elapsed
        elapsed=$(echo "$checks_json" | jq -r --argjson now "$now_epoch" '
            def ts(v): if v == null then null else (v | fromdateiso8601) end;
            ([.[].startedAt | ts(.)] | map(select(. != null)) | min) as $start
            | ([.[].completedAt | ts(.)] | map(select(. != null)) | max) as $end
            | if $start == null then "n/a"
              else ((if $end == null then $now else $end end) - $start | tostring + "s")
              end
        ')

        info "CI health summary: total=$total pass=$pass fail=$fail pending=$pending skipped=$skipped elapsed=$elapsed"
    }

    info "Validating required checks for PR #$pr_number"

    local required_json
    required_json=$(gh pr checks "$pr_number" --required --json name,state,link,bucket 2>/dev/null || echo "[]")
    local required_count
    required_count=$(echo "$required_json" | jq 'length')

    print_required_ci_summary "$required_json"

    if [ "$required_count" -eq 0 ]; then
        if [ "$PRMERGE_ALLOW_NO_REQUIRED_CHECKS" = "1" ]; then
            warning "No required checks configured; override enabled (PRMERGE_ALLOW_NO_REQUIRED_CHECKS=1)"
            return 0
        fi

        error "No required checks detected for this PR; refusing to merge by default"
        echo "Set PRMERGE_ALLOW_NO_REQUIRED_CHECKS=1 only for exceptional cases"
        return 1
    fi

    info "Waiting for required checks to complete (timeout=${PRMERGE_CI_WAIT_TIMEOUT_SECONDS}s, watch-interval=${PRMERGE_CI_WATCH_INTERVAL_SECONDS}s)"

    set +e
    timeout "$PRMERGE_CI_WAIT_TIMEOUT_SECONDS" \
        gh pr checks "$pr_number" --required --watch --fail-fast --interval "$PRMERGE_CI_WATCH_INTERVAL_SECONDS"
    local watch_rc=$?
    set -e

    if [ "$watch_rc" -eq 124 ]; then
        error "Required checks did not finish within timeout (${PRMERGE_CI_WAIT_TIMEOUT_SECONDS}s)"

        if [ "$PRMERGE_CANCEL_LONGRUNNERS" = "1" ]; then
            warning "Running long-runner watchdog (max age: ${PRMERGE_LONGRUNNER_MAX_MINUTES}m)"
            cancel_long_running_branch_runs "$branch" "$PRMERGE_LONGRUNNER_MAX_MINUTES"
        else
            warning "Watchdog cancellation disabled (PRMERGE_CANCEL_LONGRUNNERS=0)"
        fi

        echo ""
        info "Current required check states:"
        gh pr checks "$pr_number" --required || true

        local timed_out_json
        timed_out_json=$(gh pr checks "$pr_number" --required --json name,state,link,bucket,startedAt,completedAt 2>/dev/null || echo "[]")
        print_required_ci_summary "$timed_out_json"
        return 1
    fi

    if [ "$watch_rc" -ne 0 ]; then
        error "Required checks failed"
        echo ""
        info "Current required check states:"
        gh pr checks "$pr_number" --required || true

        local failed_json
        failed_json=$(gh pr checks "$pr_number" --required --json name,state,link,bucket,startedAt,completedAt 2>/dev/null || echo "[]")
        print_required_ci_summary "$failed_json"
        return 1
    fi

    local final_required_json
    final_required_json=$(gh pr checks "$pr_number" --required --json name,state,link,bucket,startedAt,completedAt 2>/dev/null || echo "[]")
    local non_pass_count
    non_pass_count=$(echo "$final_required_json" | jq '[.[] | select(.state != "PASS")] | length')

    print_required_ci_summary "$final_required_json"

    if [ "$non_pass_count" -gt 0 ]; then
        error "Required checks are not all passing"
        echo "$final_required_json" | jq -r '.[] | "  - \(.name): \(.state) (\(.link))"'
        return 1
    fi

    success "All required CI checks are complete and passing"
    return 0
}

# Detect repository context
detect_repo() {
    local current_dir="$(pwd)"
    
    # Check if we're in the client repo
    if [[ "$current_dir" == *"AI-Agent-Framework-Client"* ]]; then
        echo "client"
        return 0
    fi
    
    # Check if ../AI-Agent-Framework-Client exists (backend invoking client PR)
    if [[ -d "../AI-Agent-Framework-Client" ]]; then
        echo "backend-with-client"
        return 0
    fi
    
    # Default to backend
    echo "backend"
}

# Get repository root path
get_repo_path() {
    local repo_type="$1"
    
    case "$repo_type" in
        client)
            echo "$(pwd)"
            ;;
        backend-with-client)
            echo "$(pwd)/../AI-Agent-Framework-Client"
            ;;
        backend)
            echo "$(pwd)"
            ;;
    esac
}

# Get GitHub repository name
get_repo_name() {
    local repo_type="$1"
    
    case "$repo_type" in
        client|backend-with-client)
            echo "blecx/AI-Agent-Framework-Client"
            ;;
        backend)
            echo "blecx/AI-Agent-Framework"
            ;;
    esac
}

REPO_TYPE=$(detect_repo)
REPO_PATH=$(get_repo_path "$REPO_TYPE")
REPO_NAME=$(get_repo_name "$REPO_TYPE")

if [[ "$REPO_TYPE" == "backend-with-client" ]]; then
    info "Working with client repository: $REPO_PATH"
fi

# Detect issue type for template selection
detect_issue_type() {
    local title="$1"
    local pr_body="$2"
    local files_changed="$3"
    
    # Check title patterns first
    if [[ "$title" =~ (Infrastructure|Setup|Configuration|Foundation|API Service Layer) ]]; then
        echo "infrastructure"
    elif [[ "$title" =~ (fix:|Fix|bug:|Bug|hotfix:|Hotfix) ]]; then
        echo "bugfix"
    elif [[ "$title" =~ (docs:|Docs|documentation|Documentation) ]]; then
        echo "docs"
    else
        # Check file patterns if title is ambiguous
        # NOTE: `grep -c` prints "0" even when it exits non-zero (no matches).
        # Avoid `|| echo 0` which would append a second "0" and break numeric comparisons.
        local doc_count=$(echo "$files_changed" | grep -cE '\.md$|/docs/' || true)
        local test_count=$(echo "$files_changed" | grep -cE 'test|spec' || true)
        local total_files=$(echo "$files_changed" | wc -l)
        
        # If >50% doc files, it's a docs issue
        if [ "$total_files" -gt 0 ] && [ "$doc_count" -gt "$((total_files / 2))" ]; then
            echo "docs"
        else
            echo "feature"  # Default
        fi
    fi
}

# Capture enhanced metrics from PR
capture_pr_metrics() {
    local pr_number="$1"
    local pr_files="$2"
    local pr_additions="$3"
    local pr_deletions="$4"
    
    # Get commit count
    local commits=$(gh pr view "$pr_number" --json commits --jq '.commits | length')
    
    # Calculate complexity score
    local complexity="low"
    if [ "$pr_files" -ge 10 ]; then
        complexity="high"
    elif [ "$pr_files" -ge 5 ]; then
        complexity="medium"
    fi
    
    # Calculate test ratio (approximate)
    local test_files=$(gh pr view "$pr_number" --json files --jq '[.files[] | select(.path | test("test|spec"))] | length')
    local test_ratio="0.0"
    if [ "$pr_files" -gt 0 ]; then
        test_ratio=$(awk "BEGIN {printf \"%.2f\", $test_files / $pr_files}")
    fi
    
    # Get CI run count
    local ci_runs=$(gh run list --branch "$(gh pr view "$pr_number" --json headRefName --jq '.headRefName')" --limit 20 --json conclusion --jq 'length')
    local ci_iterations="$ci_runs"
    
    # Store metrics in temporary file for later use (workspace-scoped)
    mkdir -p .tmp
    cat > .tmp/prmerge-metrics-$pr_number.json << EOF
{
  "pr_metrics": {
    "files_changed": $pr_files,
    "additions": $pr_additions,
    "deletions": $pr_deletions,
    "commits": $commits,
    "complexity_score": "$complexity",
    "test_ratio": $test_ratio
  },
  "workflow_metrics": {
    "ci_iterations": $ci_iterations
  }
}
EOF
    
    echo "complexity=$complexity,commits=$commits,test_ratio=$test_ratio,ci_iterations=$ci_iterations"
}

# Validate PR description follows template
validate_pr_template() {
    local pr_body="$1"
    local pr_number="$2"
    local repo_name="$3"
    
    info "Validating PR description format..."
    
    local missing_sections=()
    local warnings=()

    if [ "$repo_name" = "$BACKEND_REPO_NAME" ]; then
        local required_patterns=(
            '^## Goal / Context$'
            '^## Acceptance Criteria$'
            '^## Validation Evidence$'
            '^## Repo Hygiene / Safety$'
        )
        local required_labels=(
            '## Goal / Context'
            '## Acceptance Criteria'
            '## Validation Evidence'
            '## Repo Hygiene / Safety'
        )

        for i in "${!required_patterns[@]}"; do
            if ! echo "$pr_body" | grep -Eq "${required_patterns[$i]}"; then
                missing_sections+=("${required_labels[$i]}")
            fi
        done
    else
        local required_patterns=(
            '^# Summary$'
            '^## Goal / Acceptance Criteria \(required\)$'
            '^## Issue / Tracking Link \(required\)$'
            '^## Validation \(required\)$'
            '^##+ Automated checks$'
            '^##+ Manual test evidence \(required\)$'
        )
        local required_labels=(
            '# Summary'
            '## Goal / Acceptance Criteria (required)'
            '## Issue / Tracking Link (required)'
            '## Validation (required)'
            '## Automated checks'
            '## Manual test evidence (required)'
        )

        for i in "${!required_patterns[@]}"; do
            if ! echo "$pr_body" | grep -Eq "${required_patterns[$i]}"; then
                missing_sections+=("${required_labels[$i]}")
            fi
        done
    fi
    
    # Check if Fixes: line exists (accepts #N or owner/repo#N format)
    if ! echo "$pr_body" | grep -Eq "^Fixes: (#[0-9]+|[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+#[0-9]+)"; then
        warnings+=("Missing 'Fixes: #<issue>' or 'Fixes: owner/repo#<issue>' line")
    fi
    
    # Check if acceptance criteria have checkboxes
    local ac_section=$(echo "$pr_body" | sed -n '/## Goal \/ Acceptance Criteria/,/##/p')
    if [ -n "$ac_section" ]; then
        if ! echo "$ac_section" | grep -q "\[x\]\|\[X\]"; then
            warnings+=("Acceptance criteria checkboxes not checked")
        fi
    fi
    
    # Check if automated checks are filled
    if echo "$pr_body" | grep -q "## Automated checks"; then
        local auto_section=$(echo "$pr_body" | sed -n '/## Automated checks/,/## Manual test/p')
        if echo "$auto_section" | grep -Eq "Evidence.*:$|Evidence.*: *$"; then
            warnings+=("Automated checks evidence appears empty (inline format required)")
        fi
    fi
    
    # Report results
    if [ ${#missing_sections[@]} -gt 0 ]; then
        error "PR template validation FAILED - Missing required sections:"
        for section in "${missing_sections[@]}"; do
            echo "  ‚ùå $section"
        done
        return 1
    fi
    
    if [ ${#warnings[@]} -gt 0 ]; then
        warning "PR template validation WARNINGS:"
        for warn in "${warnings[@]}"; do
            echo "  ‚ö†Ô∏è  $warn"
        done
        echo ""
        if [ "${PRMERGE_ASSUME_YES:-}" = "1" ]; then
            continue_despite_warnings="y"
            info "PRMERGE_ASSUME_YES=1: continuing despite warnings"
        else
            read -p "Continue despite warnings? (y/N): " continue_despite_warnings
        fi
        if [[ ! "$continue_despite_warnings" =~ ^[Yy]$ ]]; then
            info "Merge cancelled. Please fix PR description and re-run prmerge."
            return 1
        fi
    fi
    
    success "PR template validation passed"
    return 0
}

# Generate infrastructure template
generate_infrastructure_template() {
    local pr_number="$1"
    local pr_url="$2"
    local commit_sha="$3"
    local pr_title="$4"
    local acceptance_criteria="$5"
    local pr_files="$6"
    local pr_additions="$7"
    local pr_deletions="$8"
    local issue_number="$9"
    local metrics="${10}"
    
    cat << EOF
‚úÖ **INFRASTRUCTURE COMPLETE** in PR #$pr_number

**Merge Commit:** \`$commit_sha\`
**PR URL:** $pr_url

## Setup Complete

$pr_title

## Acceptance Criteria

$acceptance_criteria

## Components Added

**Files:** $pr_files files changed
**Lines:** +$pr_additions / -$pr_deletions
**Complexity:** $(echo "$metrics" | cut -d',' -f1 | cut -d'=' -f2)
**Commits:** $(echo "$metrics" | cut -d',' -f2 | cut -d'=' -f2)

## Testing

**CI Status:**
- ‚úÖ Build: Passing
- ‚úÖ Lint: Passing  
- ‚úÖ Tests: Passing
- ‚úÖ Type Check: Passing

**CI Iterations:** $(echo "$metrics" | cut -d',' -f4 | cut -d'=' -f2)
**Test Coverage:** Test ratio $(echo "$metrics" | cut -d',' -f3 | cut -d'=' -f2)

## Documentation

See PR #$pr_number for complete implementation details and file-by-file changes.

## Next Steps

Run \`./next-pr\` to find the next mergeable PR.

---

**Status:** ‚úÖ Complete | üöÄ Ready for next issue
**Completed:** $(date +"%Y-%m-%d %H:%M:%S")
EOF
}

# Generate feature template
generate_feature_template() {
    local pr_number="$1"
    local pr_url="$2"
    local commit_sha="$3"
    local pr_title="$4"
    local acceptance_criteria="$5"
    local pr_files="$6"
    local pr_additions="$7"
    local pr_deletions="$8"
    local issue_number="$9"
    local metrics="${10}"
    
    cat << EOF
‚úÖ **FEATURE COMPLETE** in PR #$pr_number

**Merge Commit:** \`$commit_sha\`
**PR URL:** $pr_url

## Feature Summary

$pr_title

## Acceptance Criteria

$acceptance_criteria

## Implementation

**Files:** $pr_files files changed (+$pr_additions / -$pr_deletions)
**Complexity:** $(echo "$metrics" | cut -d',' -f1 | cut -d'=' -f2)
**Commits:** $(echo "$metrics" | cut -d',' -f2 | cut -d'=' -f2)

## Testing

**CI Status:**
- ‚úÖ Build: Passing
- ‚úÖ Lint: Passing
- ‚úÖ Tests: Passing
- ‚úÖ Type Check: Passing

**Test Coverage:** Test ratio $(echo "$metrics" | cut -d',' -f3 | cut -d'=' -f2)
**CI Iterations:** $(echo "$metrics" | cut -d',' -f4 | cut -d'=' -f2)

## Documentation

See PR #$pr_number for complete details and file-by-file changes.

## Next Steps

Run \`./next-pr\` to find the next mergeable PR.

---

**Status:** ‚úÖ Complete | üöÄ Ready for next issue
**Completed:** $(date +"%Y-%m-%d %H:%M:%S")
EOF
}

# Generate bugfix template
generate_bugfix_template() {
    local pr_number="$1"
    local pr_url="$2"
    local commit_sha="$3"
    local pr_title="$4"
    local acceptance_criteria="$5"
    local pr_files="$6"
    local pr_additions="$7"
    local pr_deletions="$8"
    local issue_number="$9"
    local metrics="${10}"
    
    cat << EOF
‚úÖ **BUGFIX COMPLETE** in PR #$pr_number

**Merge Commit:** \`$commit_sha\`
**PR URL:** $pr_url

## Bug Fixed

$pr_title

## Solution

$acceptance_criteria

## Changes

**Files:** $pr_files files changed (+$pr_additions / -$pr_deletions)
**Commits:** $(echo "$metrics" | cut -d',' -f2 | cut -d'=' -f2)

## Testing

**CI Status:**
- ‚úÖ Build: Passing
- ‚úÖ Lint: Passing  
- ‚úÖ Tests: Passing (including regression tests)
- ‚úÖ Type Check: Passing

**Test Coverage:** Test ratio $(echo "$metrics" | cut -d',' -f3 | cut -d'=' -f2)
**CI Iterations:** $(echo "$metrics" | cut -d',' -f4 | cut -d'=' -f2)

## Verification

See PR #$pr_number for detailed verification steps and test results.

---

**Status:** ‚úÖ Complete | üöÄ Verified
**Completed:** $(date +"%Y-%m-%d %H:%M:%S")
EOF
}

# Generate documentation template
generate_docs_template() {
    local pr_number="$1"
    local pr_url="$2"
    local commit_sha="$3"
    local pr_title="$4"
    local acceptance_criteria="$5"
    local pr_files="$6"
    local pr_additions="$7"
    local pr_deletions="$8"
    local issue_number="$9"
    local metrics="${10}"
    
    cat << EOF
‚úÖ **DOCUMENTATION COMPLETE** in PR #$pr_number

**Merge Commit:** \`$commit_sha\`
**PR URL:** $pr_url

## Documentation Added

$pr_title

## Content

$acceptance_criteria

## Files Updated

**Documentation Files:** $pr_files files
**Lines:** +$pr_additions / -$pr_deletions
**Commits:** $(echo "$metrics" | cut -d',' -f2 | cut -d'=' -f2)

## Review

- ‚úÖ Technical Accuracy: Verified
- ‚úÖ Clarity: Reviewed
- ‚úÖ Completeness: Validated
- ‚úÖ Examples: Included

## Documentation

View complete documentation in PR #$pr_number.

---

**Status:** ‚úÖ Complete | üìñ Published
**Completed:** $(date +"%Y-%m-%d %H:%M:%S")
EOF
}

# Check arguments
if [ $# -lt 1 ]; then
    error "Usage: prmerge <issue_number> [<actual_hours>]"
    echo ""
    echo "Examples:"
    echo "  prmerge 24"
    echo "  prmerge 24 7.5"
    exit 1
fi

ISSUE_NUMBER=$1
ACTUAL_HOURS=${2:-""}

# CRITICAL GUARD: Prevent PR/issue creation attempts
# pr-merge is ONLY for merging existing PRs - delegate creation tasks
if [[ "$ISSUE_NUMBER" =~ ^(create|new|add)$ ]] || \
   [[ "$*" =~ create.*pr|new.*pr|create.*issue|new.*issue ]]; then
    error "pr-merge is for MERGING existing PRs only, not creation"
    echo ""
    echo "‚ùå Wrong tool for this task!"
    echo ""
    echo "For PR/issue creation, use the appropriate agent:"
    echo ""
    echo "  üìù To implement issue and create PR:"
    echo "     @workspace /runSubagent resolve-issue-dev \"implement issue #N\""
    echo ""
    echo "  üìù To create new issue:"
    echo "     gh issue create --title \"...\" --body \"...\""
    echo "     OR use GitHub UI: https://github.com/$REPO_NAME/issues/new"
    echo ""
    echo "  üìù To fix existing PR:"
    echo "     @workspace /runSubagent resolve-issue-dev \"fix PR #N\""
    echo ""
    echo "For help:"
    echo "  - resolve-issue-dev agent: Implements issues, creates/fixes PRs, fixes CI"
    echo "  - pr-merge: Merges existing ready PRs (this tool)"
    echo "  - close-issue agent: Closes issues with templates"
    echo ""
    exit 1
fi

# Validate issue number is numeric
if ! [[ "$ISSUE_NUMBER" =~ ^[0-9]+$ ]]; then
    error "Invalid issue number: $ISSUE_NUMBER"
    echo ""
    echo "Usage: prmerge <issue_number> [<actual_hours>]"
    echo ""
    echo "Examples:"
    echo "  prmerge 24"
    echo "  prmerge 24 7.5"
    echo ""
    exit 1
fi

# Determine repository root and working directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Backend repo root is always REPO_ROOT when this script lives in backend.
MAIN_REPO="$REPO_ROOT"
CLIENT_REPO="$REPO_ROOT/../AI-Agent-Framework-Client"

BACKEND_REPO_NAME="blecx/AI-Agent-Framework"
CLIENT_REPO_NAME="blecx/AI-Agent-Framework-Client"

WORK_REPO_DIR="$MAIN_REPO"
WORK_REPO_NAME="$BACKEND_REPO_NAME"

get_issue_state() {
    local repo="$1"
    gh issue view "$ISSUE_NUMBER" --repo "$repo" --json state --jq '.state' 2>/dev/null || true
}

find_open_pr_for_issue() {
    local repo="$1"
    local issue_number="$2"

    # Heuristic: look for an OPEN PR whose title OR body references the issue number.
    # Common patterns: "Fixes #123", "Closes #123", "Resolves #123".
    # Keep this fast and resilient: any gh/jq failure returns empty.
    gh pr list \
        --repo "$repo" \
        --state open \
        --limit 200 \
        --json number,title,body \
        --jq ".[]
            | select(
                (((.title // \"\") | test(\"#${issue_number}([^0-9]|$)\")) or (((.title // \"\") | test(\"[Ii]ssue[[:space:]]*#?${issue_number}([^0-9]|$)\"))))
                or
                (((.body // \"\") | ascii_downcase) | test(\"(fix|fixes|fixed|close|closes|closed|resolve|resolves|resolved)[[:space:]]*:?[[:space:]]*#?${issue_number}([^0-9]|$)\"))
            )
            | .number" \
        2>/dev/null \
        | head -1 \
        || true
}

# Explicit repo override for ambiguous issue numbers (exists in both repos).
# Values:
#   PRMERGE_REPO=backend|client
#   PRMERGE_REPO=blecx/AI-Agent-Framework|blecx/AI-Agent-Framework-Client
REPO_OVERRIDE_SET=""
if [ -n "${PRMERGE_REPO:-}" ]; then
    case "$PRMERGE_REPO" in
        backend|"$BACKEND_REPO_NAME")
            WORK_REPO_DIR="$MAIN_REPO"
            WORK_REPO_NAME="$BACKEND_REPO_NAME"
            REPO_OVERRIDE_SET="1"
            info "PRMERGE_REPO override: selecting backend"
            ;; 
        client|"$CLIENT_REPO_NAME")
            if [ ! -f "$CLIENT_REPO/package.json" ]; then
                error "PRMERGE_REPO=client requested, but client repo not found at: $CLIENT_REPO"
                exit 1
            fi
            WORK_REPO_DIR="$CLIENT_REPO"
            WORK_REPO_NAME="$CLIENT_REPO_NAME"
            REPO_OVERRIDE_SET="1"
            info "PRMERGE_REPO override: selecting client"
        ;;
        *)
            error "Invalid PRMERGE_REPO value: $PRMERGE_REPO"
            echo "Allowed: backend|client|$BACKEND_REPO_NAME|$CLIENT_REPO_NAME"
            exit 1
            ;;
    esac
fi

BACKEND_ISSUE_STATE=""
CLIENT_ISSUE_STATE=""
if [ -z "$REPO_OVERRIDE_SET" ]; then
    BACKEND_ISSUE_STATE="$(get_issue_state "$BACKEND_REPO_NAME")"
    if [ -f "$CLIENT_REPO/package.json" ]; then
        CLIENT_ISSUE_STATE="$(get_issue_state "$CLIENT_REPO_NAME")"
    fi
fi

if [ -z "$REPO_OVERRIDE_SET" ]; then
    if [ -n "$BACKEND_ISSUE_STATE" ] && [ -n "$CLIENT_ISSUE_STATE" ]; then
        # Both repos have this issue number. Prefer the one that is still OPEN.
        if [ "$CLIENT_ISSUE_STATE" = "OPEN" ] && [ "$BACKEND_ISSUE_STATE" != "OPEN" ]; then
            WORK_REPO_DIR="$CLIENT_REPO"
            WORK_REPO_NAME="$CLIENT_REPO_NAME"
            warning "Issue #$ISSUE_NUMBER exists in both repos; selecting client because it is OPEN (backend is $BACKEND_ISSUE_STATE)"
        elif [ "$BACKEND_ISSUE_STATE" = "OPEN" ] && [ "$CLIENT_ISSUE_STATE" != "OPEN" ]; then
            WORK_REPO_DIR="$MAIN_REPO"
            WORK_REPO_NAME="$BACKEND_REPO_NAME"
            warning "Issue #$ISSUE_NUMBER exists in both repos; selecting backend because it is OPEN (client is $CLIENT_ISSUE_STATE)"
        else
            # Both OPEN or both CLOSED: try to disambiguate by presence of an open PR.
            BACKEND_OPEN_PR="$(find_open_pr_for_issue "$BACKEND_REPO_NAME" "$ISSUE_NUMBER")"
            CLIENT_OPEN_PR=""
            if [ -f "$CLIENT_REPO/package.json" ]; then
                CLIENT_OPEN_PR="$(find_open_pr_for_issue "$CLIENT_REPO_NAME" "$ISSUE_NUMBER")"
            fi

            if [ -n "$CLIENT_OPEN_PR" ] && [ -z "$BACKEND_OPEN_PR" ]; then
                WORK_REPO_DIR="$CLIENT_REPO"
                WORK_REPO_NAME="$CLIENT_REPO_NAME"
                warning "Issue #$ISSUE_NUMBER exists in both repos (backend=$BACKEND_ISSUE_STATE, client=$CLIENT_ISSUE_STATE); selecting client due to open PR #$CLIENT_OPEN_PR"
            elif [ -n "$BACKEND_OPEN_PR" ] && [ -z "$CLIENT_OPEN_PR" ]; then
                WORK_REPO_DIR="$MAIN_REPO"
                WORK_REPO_NAME="$BACKEND_REPO_NAME"
                warning "Issue #$ISSUE_NUMBER exists in both repos (backend=$BACKEND_ISSUE_STATE, client=$CLIENT_ISSUE_STATE); selecting backend due to open PR #$BACKEND_OPEN_PR"
            else
                WORK_REPO_DIR="$MAIN_REPO"
                WORK_REPO_NAME="$BACKEND_REPO_NAME"
                warning "Issue #$ISSUE_NUMBER exists in both repos (backend=$BACKEND_ISSUE_STATE, client=$CLIENT_ISSUE_STATE); defaulting to backend"
            fi
        fi
    elif [ -n "$BACKEND_ISSUE_STATE" ]; then
        WORK_REPO_DIR="$MAIN_REPO"
        WORK_REPO_NAME="$BACKEND_REPO_NAME"
    elif [ -n "$CLIENT_ISSUE_STATE" ]; then
        WORK_REPO_DIR="$CLIENT_REPO"
        WORK_REPO_NAME="$CLIENT_REPO_NAME"
    else
        error "Issue #$ISSUE_NUMBER not found in backend or client repo"
        echo "Tried: $BACKEND_REPO_NAME and $CLIENT_REPO_NAME"
        exit 1
    fi
fi

info "Working repository: $WORK_REPO_NAME ($WORK_REPO_DIR)"
cd "$WORK_REPO_DIR"

section "Step 1: Validate PR and CI Status"

# Find PR number for this issue
info "Finding PR for Issue #$ISSUE_NUMBER..."
PR_NUMBER=""

# Allow explicit override (e.g., for unusual titles/search failures)
if [ -n "${PRMERGE_PR_NUMBER:-}" ]; then
    PR_NUMBER="$PRMERGE_PR_NUMBER"
fi

if [ -z "$PR_NUMBER" ]; then
    PR_NUMBER=$(gh pr list --search "issue #$ISSUE_NUMBER in:title" --state all --json number --jq '.[0].number' 2>/dev/null)
    PR_LIST_EXIT=$?
    if [ $PR_LIST_EXIT -ne 0 ]; then
        error "Failed to search PRs via gh (exit=$PR_LIST_EXIT). Check auth/rate limits and retry."
        exit 1
    fi
fi

if [ -z "$PR_NUMBER" ]; then
    info "No PR found by exact title pattern; attempting alternate search pattern..."
    PR_NUMBER=$(gh pr list --search "$ISSUE_NUMBER" --state all --json number,title --jq ".[] | select(.title | contains(\"#$ISSUE_NUMBER\") or contains(\"Issue $ISSUE_NUMBER\")) | .number" | head -1 2>/dev/null)
    PR_ALT_EXIT=$?
    if [ $PR_ALT_EXIT -ne 0 ]; then
        error "Failed to run alternate PR search via gh (exit=$PR_ALT_EXIT). Check auth/rate limits and retry."
        exit 1
    fi

    if [ -z "$PR_NUMBER" ]; then
        info "No PR found by title; searching open PR bodies for issue references (Fixes/Closes/Resolves)..."
        PR_NUMBER=$(gh pr list --state open --limit 200 --json number,title,body --jq ".[]
            | select(
                (((.title // \"\") | test(\"#${ISSUE_NUMBER}([^0-9]|$)\")) or (((.title // \"\") | test(\"[Ii]ssue[[:space:]]*#?${ISSUE_NUMBER}([^0-9]|$)\"))))
                or
                (((.body // \"\") | ascii_downcase) | test(\"(fix|fixes|fixed|close|closes|closed|resolve|resolves|resolved)[[:space:]]*:?[[:space:]]*#?${ISSUE_NUMBER}([^0-9]|$)\"))
            )
            | .number" | head -1 2>/dev/null)

        if [ -z "$PR_NUMBER" ]; then
            warning "No PR found for Issue #$ISSUE_NUMBER. Nothing to merge."
            info "Either title the PR with '#$ISSUE_NUMBER', include 'Fixes #$ISSUE_NUMBER' in the body, or set PRMERGE_PR_NUMBER=<pr>."
            exit 0
        fi
    fi
fi

success "Found PR #$PR_NUMBER"

# Get PR details
info "Checking PR status..."
PR_JSON=$(gh pr view "$PR_NUMBER" --json number,title,state,mergeable,mergeStateStatus,statusCheckRollup,headRefName,url,reviewDecision)
PR_STATE=$(echo "$PR_JSON" | jq -r '.state')
PR_TITLE=$(echo "$PR_JSON" | jq -r '.title')
PR_MERGEABLE=$(echo "$PR_JSON" | jq -r '.mergeable')
PR_MERGE_STATE=$(echo "$PR_JSON" | jq -r '.mergeStateStatus')
PR_BRANCH=$(echo "$PR_JSON" | jq -r '.headRefName')
PR_URL=$(echo "$PR_JSON" | jq -r '.url')
PR_REVIEW_DECISION=$(echo "$PR_JSON" | jq -r '.reviewDecision // ""')

echo ""
echo "PR Details:"
echo "  Number: #$PR_NUMBER"
echo "  Title: $PR_TITLE"
echo "  State: $PR_STATE"
echo "  Branch: $PR_BRANCH"
echo "  URL: $PR_URL"
echo "  Review decision: ${PR_REVIEW_DECISION:-NONE}"
echo ""

# Check if already merged
if [ "$PR_STATE" = "MERGED" ]; then
    success "PR #$PR_NUMBER is already merged!"
    
    # Get merge commit
    MERGE_COMMIT=$(gh pr view "$PR_NUMBER" --json mergeCommit --jq '.mergeCommit.oid')
    MERGE_COMMIT_SHORT="${MERGE_COMMIT:0:7}"
    
    info "Merge commit: $MERGE_COMMIT_SHORT"
    
    # Check if issue is closed
    ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state')
    
    if [ "$ISSUE_STATE" = "CLOSED" ]; then
        success "Issue #$ISSUE_NUMBER is already closed"
        
        if [ -n "$ACTUAL_HOURS" ]; then
            info "Recording completion time..."
            cd "$MAIN_REPO"
            ./scripts/record-completion.py "$ISSUE_NUMBER" "$ACTUAL_HOURS" "Completed via prmerge script"
            success "Completion recorded"
        else
            warning "Completion time not recorded. Run: ./scripts/record-completion.py $ISSUE_NUMBER <hours> '<notes>'"
        fi
        
        info "Run './next-pr' to find the next mergeable PR"
        exit 0
    else
        warning "Issue #$ISSUE_NUMBER is still open. Proceeding to close..."
        # Continue to issue closing section
    fi
else
    # PR not yet merged, enforce strict required-check CI gate
    if ! wait_for_required_ci_checks "$PR_NUMBER" "$PR_BRANCH"; then
        warning "Please fix CI status before merging"
        warning "PR URL: $PR_URL"
        exit 1
    fi
    
    # Validate PR template
    info "Validating PR description format..."
    PR_BODY=$(gh pr view "$PR_NUMBER" --json body --jq '.body')
    if ! validate_pr_template "$PR_BODY" "$PR_NUMBER" "$WORK_REPO_NAME"; then
        error "PR template validation failed. Please fix the PR description."
        warning "PR URL: $PR_URL"
        exit 1
    fi

    # Enforce small-slice policy for CI-friendly merges
    PR_FILES_POLICY=$(gh pr view "$PR_NUMBER" --json files --jq '.files | length')
    PR_ADDITIONS_POLICY=$(gh pr view "$PR_NUMBER" --json additions --jq '.additions')
    PR_DELETIONS_POLICY=$(gh pr view "$PR_NUMBER" --json deletions --jq '.deletions')
    PR_TOTAL_LINES_POLICY=$((PR_ADDITIONS_POLICY + PR_DELETIONS_POLICY))
    PR_CHANGED_FILES=$(gh pr view "$PR_NUMBER" --json files --jq '.files[].path')

    # Enforce dedicated merge path for GitHub workflow file changes
    if [ "$PRMERGE_ALLOW_WORKFLOW_FILES" != "1" ]; then
        WORKFLOW_FILES=$(echo "$PR_CHANGED_FILES" | sed 's/^"//;s/"$//' | grep '^\.github/workflows/.*\.ya\?ml$' || true)
        if [ -n "$WORKFLOW_FILES" ]; then
            error "PR modifies GitHub workflow files; blocked by default merge policy"
            echo ""
            echo "Workflow files detected:"
            echo "$WORKFLOW_FILES" | sed 's/^/  - /'
            echo ""
            echo "Use dedicated workflow-change PR/merge path with elevated token scope, or explicit override for exceptional cases:"
            echo "  PRMERGE_ALLOW_WORKFLOW_FILES=1 ./scripts/prmerge $ISSUE_NUMBER"
            exit 1
        fi
    fi

    info "Domain-specific validation guidance"
    if echo "$PR_CHANGED_FILES" | grep -Eq 'tests/|apps/api/|agents/|scripts/'; then
        echo "  - Backend scope detected: run focused pytest for touched domain before merge"
    fi
    if echo "$PR_CHANGED_FILES" | grep -Eq '^"client/|\.tsx"$|\.jsx"$'; then
        echo "  - Frontend scope detected: run npm lint/build or focused UI tests before merge"
    fi
    if echo "$PR_CHANGED_FILES" | grep -Eq '\.md"$|docs/'; then
        echo "  - Docs-only scope: keep validation lightweight (policy/docs checks)"
    fi

    if [ "$PRMERGE_ALLOW_LARGE_SLICE" != "1" ]; then
        if [ "$PR_FILES_POLICY" -gt "$PRMERGE_MAX_FILES" ] || [ "$PR_TOTAL_LINES_POLICY" -gt "$PRMERGE_MAX_LINES" ]; then
            error "PR exceeds small-slice merge policy"
            echo ""
            echo "Policy limits: files <= $PRMERGE_MAX_FILES, total changed lines <= $PRMERGE_MAX_LINES"
            echo "PR metrics: files=$PR_FILES_POLICY, additions=$PR_ADDITIONS_POLICY, deletions=$PR_DELETIONS_POLICY, total=$PR_TOTAL_LINES_POLICY"
            echo ""
            echo "Split into smaller slices before merge, or explicitly override for exceptional cases:"
            echo "  PRMERGE_ALLOW_LARGE_SLICE=1 ./scripts/prmerge $ISSUE_NUMBER"
            exit 1
        fi
    fi

    # Enforce mandatory review approval gate
    if [ "$PRMERGE_ALLOW_UNAPPROVED" != "1" ]; then
        if [ "$PR_REVIEW_DECISION" != "APPROVED" ]; then
            error "PR review gate failed: reviewDecision is '${PR_REVIEW_DECISION:-NONE}' (requires APPROVED)"
            echo ""
            echo "Please complete review approval in GitHub before merge: $PR_URL"
            echo "For exceptional override only:"
            echo "  PRMERGE_ALLOW_UNAPPROVED=1 ./scripts/prmerge $ISSUE_NUMBER"
            exit 1
        fi
    fi
    
    section "Step 2: Review PR"
    
    info "Opening PR in browser for review..."
    if command -v xdg-open &> /dev/null; then
        xdg-open "$PR_URL" &> /dev/null || true
    elif command -v open &> /dev/null; then
        open "$PR_URL" &> /dev/null || true
    fi
    
    echo ""
    echo "Please review the PR:"
    echo "  - Check code quality and architecture"
    echo "  - Verify tests are comprehensive"
    echo "  - Ensure documentation is complete"
    echo "  - Validate acceptance criteria are met"
    echo ""
    
    if [ "${PRMERGE_ASSUME_YES:-}" = "1" ]; then
        pr_approved="y"
        info "PRMERGE_ASSUME_YES=1: skipping interactive review confirmation"
    else
        read -p "Has the PR been reviewed and approved? (y/N): " pr_approved
    fi
    if [[ ! "$pr_approved" =~ ^[Yy]$ ]]; then
        info "Please complete review before merging"
        exit 0
    fi
    
    section "Step 3: Merge PR"
    
    # Check if branch protection requires approval
    if [ "$PR_MERGE_STATE" = "BLOCKED" ]; then
        warning "PR is blocked by branch protection"
        echo ""
        echo "Options to unblock:"
        echo "  A) Approve via GitHub UI: $PR_URL"
        echo "  B) Temporarily disable branch protection"
        echo "  C) Manual git merge (bypass GitHub PR)"
        echo ""
        if [ "${PRMERGE_ASSUME_YES:-}" = "1" ]; then
            error "PR is BLOCKED and PRMERGE_ASSUME_YES=1 is set; refusing to guess an unblock option"
            echo "Resolve branch protection in GitHub first: $PR_URL"
            exit 1
        fi

        read -p "Which option? (A/B/C): " unblock_option
        
        case "${unblock_option^^}" in
            A)
                info "Please approve the PR at: $PR_URL"
                if [ "${PRMERGE_ASSUME_YES:-}" != "1" ]; then
                    read -p "Press Enter after approving..."
                fi
                ;;
            B)
                warning "Temporarily disabling branch protection"
                warning "Remember to re-enable it after merge!"
                if [ "${PRMERGE_ASSUME_YES:-}" != "1" ]; then
                    read -p "Press Enter after disabling protection..."
                fi
                ;;
            C)
                info "Performing manual git merge..."
                git fetch origin
                git checkout main
                git pull origin main
                git merge --squash "origin/$PR_BRANCH"
                git commit -m "[$PR_TITLE]"
                git push origin main
                
                # Close PR manually
                gh pr close "$PR_NUMBER" --comment "Merged manually via git"
                
                success "Manual merge complete"
                MERGE_COMMIT=$(git log -1 --format="%H")
                MERGE_COMMIT_SHORT="${MERGE_COMMIT:0:7}"
                
                # Continue to issue closing
                ;;
            *)
                error "Invalid option"
                exit 1
                ;;
        esac
    fi
    
    # Attempt merge if not manually merged
    if [ "$PR_STATE" != "MERGED" ]; then
        info "Attempting to merge PR #$PR_NUMBER..."
        
        # Try merge with squash
        if gh pr merge "$PR_NUMBER" --squash --delete-branch 2>&1; then
            success "PR merged successfully!"
        else
            error "Merge failed. Trying with --admin flag..."
            
            if gh pr merge "$PR_NUMBER" --squash --delete-branch --admin 2>&1; then
                success "PR merged with admin override!"
            else
                error "Merge failed even with admin flag"
                error "Please merge manually at: $PR_URL"
                exit 1
            fi
        fi
        
        # Get merge commit (avoid fixed sleep; fetch immediately)
        MERGE_COMMIT=$(gh pr view "$PR_NUMBER" --json mergeCommit --jq '.mergeCommit.oid // ""')
        if [ -z "$MERGE_COMMIT" ]; then
            warning "Merge commit not immediately available; refreshing once"
            MERGE_COMMIT=$(gh pr view "$PR_NUMBER" --json mergeCommit --jq '.mergeCommit.oid // ""')
        fi

        if [ -z "$MERGE_COMMIT" ]; then
            error "Unable to resolve merge commit SHA after merge"
            exit 1
        fi

        MERGE_COMMIT_SHORT="${MERGE_COMMIT:0:7}"
        
        success "Merge commit: $MERGE_COMMIT_SHORT"
    fi
fi

section "Step 4: Generate Issue Closing Message"

# Pull latest changes
git checkout main 2>/dev/null || true
git pull origin main

info "Analyzing PR changes..."

# Get PR details for closing message
PR_FILES=$(gh pr view "$PR_NUMBER" --json files --jq '.files | length')
PR_ADDITIONS=$(gh pr view "$PR_NUMBER" --json additions --jq '.additions')
PR_DELETIONS=$(gh pr view "$PR_NUMBER" --json deletions --jq '.deletions')
PR_BODY=$(gh pr view "$PR_NUMBER" --json body --jq '.body')
PR_FILES_LIST=$(gh pr view "$PR_NUMBER" --json files --jq '.files[].path')

# Extract acceptance criteria from PR body
ACCEPTANCE_CRITERIA=$(echo "$PR_BODY" | sed -n '/## Goal \/ Acceptance Criteria/,/##/p' | grep -E '^\s*[-*]' | sed 's/^/- ‚úÖ /' || echo "")

if [ -z "$ACCEPTANCE_CRITERIA" ]; then
    warning "Could not extract acceptance criteria from PR body"
    ACCEPTANCE_CRITERIA="- ‚úÖ All requirements met per Issue #$ISSUE_NUMBER"
fi

# Capture enhanced metrics
info "Capturing PR metrics..."
METRICS=$(capture_pr_metrics "$PR_NUMBER" "$PR_FILES" "$PR_ADDITIONS" "$PR_DELETIONS")
info "Metrics: $METRICS"

# Detect issue type
info "Detecting issue type..."
ISSUE_TYPE=$(detect_issue_type "$PR_TITLE" "$PR_BODY" "$PR_FILES_LIST")
success "Detected type: $ISSUE_TYPE"

# Create closing message using workspace-scoped temp file
mkdir -p .tmp
CLOSING_MESSAGE_FILE=".tmp/close-issue-${ISSUE_NUMBER}-pr-${PR_NUMBER}-$$.md"

case "$ISSUE_TYPE" in
    infrastructure)
        generate_infrastructure_template "$PR_NUMBER" "$PR_URL" "$MERGE_COMMIT_SHORT" "$PR_TITLE" "$ACCEPTANCE_CRITERIA" "$PR_FILES" "$PR_ADDITIONS" "$PR_DELETIONS" "$ISSUE_NUMBER" "$METRICS" > "$CLOSING_MESSAGE_FILE"
        ;;
    bugfix)
        generate_bugfix_template "$PR_NUMBER" "$PR_URL" "$MERGE_COMMIT_SHORT" "$PR_TITLE" "$ACCEPTANCE_CRITERIA" "$PR_FILES" "$PR_ADDITIONS" "$PR_DELETIONS" "$ISSUE_NUMBER" "$METRICS" > "$CLOSING_MESSAGE_FILE"
        ;;
    docs)
        generate_docs_template "$PR_NUMBER" "$PR_URL" "$MERGE_COMMIT_SHORT" "$PR_TITLE" "$ACCEPTANCE_CRITERIA" "$PR_FILES" "$PR_ADDITIONS" "$PR_DELETIONS" "$ISSUE_NUMBER" "$METRICS" > "$CLOSING_MESSAGE_FILE"
        ;;
    feature|*)
        generate_feature_template "$PR_NUMBER" "$PR_URL" "$MERGE_COMMIT_SHORT" "$PR_TITLE" "$ACCEPTANCE_CRITERIA" "$PR_FILES" "$PR_ADDITIONS" "$PR_DELETIONS" "$ISSUE_NUMBER" "$METRICS" > "$CLOSING_MESSAGE_FILE"
        ;;
esac

success "Generated $ISSUE_TYPE closing message with enhanced metrics"

section "Step 5: Close Issue"

# Check if issue exists and is open
ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state' 2>/dev/null || echo "NOTFOUND")

if [ "$ISSUE_STATE" = "NOTFOUND" ]; then
    error "Issue #$ISSUE_NUMBER not found"
    exit 1
elif [ "$ISSUE_STATE" = "CLOSED" ]; then
    success "Issue #$ISSUE_NUMBER is already closed"
else
    info "Closing Issue #$ISSUE_NUMBER..."
    
    if gh issue close "$ISSUE_NUMBER" --comment "$(cat "$CLOSING_MESSAGE_FILE")"; then
        success "Issue #$ISSUE_NUMBER closed with comprehensive message"
    else
        error "Failed to close issue"
        warning "Closing message saved to: $CLOSING_MESSAGE_FILE"
        exit 1
    fi
fi

# Clean up temp file
rm -f "$CLOSING_MESSAGE_FILE"

section "Step 6: Record Completion"

cd "$MAIN_REPO"

if [ -n "$ACTUAL_HOURS" ]; then
    info "Recording completion time: $ACTUAL_HOURS hours"
    
    # Optional learning prompts (can be skipped)
    echo ""
    info "Optional: Provide learning data for future estimates (press Enter to skip)"
    if [ "${PRMERGE_ASSUME_YES:-}" = "1" ]; then
        CHALLENGES=""
        TIME_SINK=""
        LEARNING=""
    else
        read -p "Unexpected challenges encountered (optional): " CHALLENGES
        read -p "Main time sink if any (optional): " TIME_SINK
        read -p "Key learning/insight (optional): " LEARNING
    fi
    
    # Build notes string
    NOTES="Completed via prmerge - Merge: $MERGE_COMMIT_SHORT"
    if [ -n "$CHALLENGES" ]; then
        NOTES="$NOTES | Challenges: $CHALLENGES"
    fi
    if [ -n "$TIME_SINK" ]; then
        NOTES="$NOTES | Time sink: $TIME_SINK"
    fi
    if [ -n "$LEARNING" ]; then
        NOTES="$NOTES | Learning: $LEARNING"
    fi
    
    # Add metrics to notes
    if [ -f ".tmp/prmerge-metrics-$PR_NUMBER.json" ]; then
        NOTES="$NOTES | Metrics: $(cat .tmp/prmerge-metrics-$PR_NUMBER.json)"
        rm -f ".tmp/prmerge-metrics-$PR_NUMBER.json"
    fi
    
    if [ -f "./scripts/record-completion.py" ]; then
        ./scripts/record-completion.py "$ISSUE_NUMBER" "$ACTUAL_HOURS" "$NOTES"
        success "Completion recorded in learning system with enhanced metrics"
    else
        warning "record-completion.py not found, skipping"
    fi
else
    warning "Actual hours not provided, skipping completion recording"
    info "To record later: ./scripts/record-completion.py $ISSUE_NUMBER <hours> '<notes>'"
fi

section "Step 7: Verification and Summary"

# Verify PR is merged
info "Verifying PR merge status..."
FINAL_PR_STATE=$(gh pr view "$PR_NUMBER" --json state --jq '.state')
if [ "$FINAL_PR_STATE" != "MERGED" ]; then
    error "PR #$PR_NUMBER is not in MERGED state (current: $FINAL_PR_STATE)"
    exit 1
fi
success "‚úì PR #$PR_NUMBER is MERGED"

# Verify issue is closed
info "Verifying issue closure..."
FINAL_ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state,closedAt --jq '.state')
ISSUE_CLOSED_AT=$(gh issue view "$ISSUE_NUMBER" --json closedAt --jq '.closedAt')
if [ "$FINAL_ISSUE_STATE" != "CLOSED" ]; then
    error "Issue #$ISSUE_NUMBER is not CLOSED (current: $FINAL_ISSUE_STATE)"
    exit 1
fi
success "‚úì Issue #$ISSUE_NUMBER is CLOSED (at $ISSUE_CLOSED_AT)"

# Verify issue has closing comment
info "Verifying issue closing message..."
ISSUE_COMMENTS=$(gh issue view "$ISSUE_NUMBER" --json comments --jq '.comments | length')
if [ "$ISSUE_COMMENTS" -eq 0 ]; then
    warning "Issue has no comments (closing message may be missing)"
else
    LAST_COMMENT=$(gh issue view "$ISSUE_NUMBER" --json comments --jq '.comments[-1].body')
    if echo "$LAST_COMMENT" | grep -q "COMPLETE\|PR #$PR_NUMBER"; then
        success "‚úì Comprehensive closing message posted"
    else
        warning "Last comment may not be the closing message"
    fi
fi

success "All verifications passed!"
echo ""

success "PR Merge Workflow Complete!"
echo ""
echo "Summary:"
echo "  - Issue Type: $ISSUE_TYPE"
echo "  - PR #$PR_NUMBER merged: $PR_URL"
echo "  - Merge commit: $MERGE_COMMIT_SHORT"
echo "  - Issue #$ISSUE_NUMBER closed with $ISSUE_TYPE template"
echo "  - Files changed: $PR_FILES (+$PR_ADDITIONS/-$PR_DELETIONS)"
echo "  - Complexity: $(echo "$METRICS" | cut -d',' -f1 | cut -d'=' -f2)"
echo "  - CI iterations: $(echo "$METRICS" | cut -d',' -f4 | cut -d'=' -f2)"
if [ -n "$ACTUAL_HOURS" ]; then
    echo "  - Completion recorded: $ACTUAL_HOURS hours with enhanced metrics"
fi
echo ""

# Display lessons learned from Issue #25 (if applicable)
if [ "$ISSUE_NUMBER" = "25" ] || [ "$ISSUE_TYPE" = "infrastructure" ]; then
    section "Lessons Learned (Issue #25 Pattern)"
    echo "Key insights from routing infrastructure implementation:"
    echo ""
    echo "What worked well:"
    echo "  ‚úÖ Detailed planning document saved 1-2 hours implementation time"
    echo "  ‚úÖ Test-first approach caught issues early (12 tests written alongside code)"
    echo "  ‚úÖ Self-review caught critical mistakes before user review (MANDATORY gate)"
    echo "  ‚úÖ Copilot review improved UX (layout consistency fixes)"
    echo "  ‚úÖ Phase commits enabled clear progress tracking and easy rollback"
    echo ""
    echo "PR template lessons:"
    echo "  ‚ö†Ô∏è  Evidence format matters: Inline summaries required, not code blocks"
    echo "  ‚ö†Ô∏è  CI validation strict: All checkboxes must be checked, no placeholders"
    echo "  ‚ö†Ô∏è  Fix PR description BEFORE push to avoid CI re-runs"
    echo ""
    echo "Process improvements:"
    echo "  üìù Always create docs/issues/issue-N-context.md in Phase 2"
    echo "  üìù Never remove existing features without user confirmation"
    echo "  üìù Verify everything with actual command output (no assumptions)"
    echo "  üìù Build frequently during development, not just at end"
    echo ""
fi

echo "Next steps:"
echo "  1. Run './next-pr' to find the next mergeable PR"
echo "  2. Review PR diffs + CI evidence"
echo "  3. Merge (squash) when ready"
echo ""

# Offer to run next-pr
run_next_pr="n"
if [ -t 0 ]; then
    # Interactive shell: ask the user.
    if [ "${PRMERGE_ASSUME_YES:-}" = "1" ]; then
        run_next_pr="n"
    else
        read -p "Run './next-pr' now? (Y/n): " run_next_pr || run_next_pr="n"
    fi
fi

if [[ ! "$run_next_pr" =~ ^[Nn]$ ]]; then
    echo ""
    if [ -f "./scripts/next-pr.py" ]; then
        ./scripts/next-pr.py
    else
        warning "next-pr.py not found"
        info "Please run manually: cd $MAIN_REPO && ./scripts/next-pr.py"
    fi
fi

success "All done! üöÄ"
