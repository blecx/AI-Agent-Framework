{
  "version": "1.0.0",
  "last_updated": "2026-01-19T22:00:00.000000",
  "description": "Best practices learned from recent issue resolutions to improve resolve-issue-dev agent efficiency",
  "recent_issues_analyzed": [59, 38],
  "best_practices": {
    "pr_template_compliance": {
      "priority": "critical",
      "learnings": [
        {
          "practice": "Use inline evidence format, never code blocks",
          "problem": "PR #83 (Issue #59 Part 4) CI failed due to multi-line code blocks in evidence section",
          "solution": "Format: 'Build ✓ 188 modules. Tests: 258/258. Lint: Clean' (inline, no ```blocks)",
          "validation": "Check .github/workflows/pr-validate.yml for exact format requirements",
          "first_seen": 59
        },
        {
          "practice": "All required PR template sections must be present",
          "problem": "Missing or renamed sections cause CI validation failures",
          "solution": "Use exact field names from PR template (e.g., 'Actual result / Evidence' not 'Actual result / Evidence (screenshots...)')",
          "validation": "grep for section headers in .github/pull_request_template.md before PR creation",
          "first_seen": 59
        },
        {
          "practice": "Cross-repo impact section must include specific line",
          "problem": "PR validation expects exact format for multi-repo projects",
          "solution": "Always include: '- Related repos/services impacted:' even if None",
          "validation": "Check for 'Related repos/services impacted:' in PR body",
          "first_seen": 59
        },
        {
          "practice": "Update PR body via REST API, not gh pr edit",
          "problem": "gh pr edit may fail due to deprecated GitHub Projects (classic) GraphQL API",
          "solution": "Use: gh api -X PATCH repos/<owner>/<repo>/pulls/<PR> --field body=@.tmp/pr-body.md",
          "validation": "Use .tmp/ directory (gitignored) instead of /tmp for better tool access",
          "first_seen": 59
        },
        {
          "practice": "Trigger CI rerun after PR body update",
          "problem": "PR review-gate workflows validate PR body from pull_request event payload, not updated body",
          "solution": "Push an empty commit after updating PR body to trigger pull_request:synchronize event",
          "validation": "git commit --allow-empty -m 'chore: trigger CI with updated PR description'",
          "first_seen": 59
        }
      ]
    },
    "typescript_strict_mode": {
      "priority": "high",
      "learnings": [
        {
          "practice": "RefObject types must allow null",
          "problem": "Issue #59: Type error with React.RefObject expecting null possibility",
          "solution": "Use React.RefObject<HTMLDivElement | null> instead of React.RefObject<HTMLDivElement>",
          "validation": "Check tsconfig.json for strictNullChecks: true",
          "first_seen": 59
        },
        {
          "practice": "Use type-only imports with verbatimModuleSyntax",
          "problem": "Issue #59: Unused imports causing linting errors with strict TS config",
          "solution": "import type { WorkflowState } from '../types' for type-only imports",
          "validation": "Run npm run lint to catch unused imports",
          "first_seen": 59
        },
        {
          "practice": "Remove unused imports proactively",
          "problem": "Issue #59: initCreateRAIDConversation imported but never used",
          "solution": "Review all imports after implementation, remove unused ones",
          "validation": "ESLint will flag unused imports with proper config",
          "first_seen": 59
        },
        {
          "practice": "Avoid any types - use proper interfaces",
          "problem": "Issue #59: any types bypass type safety and cause runtime errors",
          "solution": "Define proper interfaces or use existing types from '../types'",
          "validation": "Check for 'any' keyword in new code, replace with specific types",
          "first_seen": 59
        },
        {
          "practice": "Use React.createRef() instead of manual objects",
          "problem": "Issue #59: {current: null} doesn't satisfy RefObject type",
          "solution": "import { createRef } from 'react' and use createRef<HTMLDivElement>()",
          "validation": "Type checker will validate RefObject compatibility",
          "first_seen": 59
        }
      ]
    },
    "test_mocking_patterns": {
      "priority": "high",
      "learnings": [
        {
          "practice": "Use vi.spyOn on existing apiClient, not new mock instances",
          "problem": "Issue #38: Initial tests tried to mock axios.create() instead of using apiClient",
          "solution": "Pattern: vi.spyOn(apiClient['client'], 'get/patch/post').mockResolvedValue({data: ...})",
          "validation": "Review existing test files (e.g., raidApiClient.test.tsx) for pattern consistency",
          "first_seen": 38
        },
        {
          "practice": "Mock return types must match actual function signatures",
          "problem": "Issue #59: CommandIntent mocks missing originalMessage property",
          "solution": "Add all required properties to mock objects, check interface definitions",
          "validation": "TypeScript compiler will catch missing properties if types are properly applied",
          "first_seen": 59
        },
        {
          "practice": "Use correct testing library queries for multiple matches",
          "problem": "Issue #59: getByText fails when multiple elements match",
          "solution": "Use getAllByText when expecting multiple matches, check array length",
          "validation": "Test error messages will indicate if query returns multiple elements",
          "first_seen": 59
        }
      ]
    },
    "api_client_patterns": {
      "priority": "high",
      "learnings": [
        {
          "practice": "All API methods return ApiResponse<T> wrapper",
          "problem": "Issue #38: Consistent error handling across all API methods",
          "solution": "Return {success: true, data: T} or {success: false, error: string}",
          "validation": "Check existing apiClient.ts methods for pattern",
          "first_seen": 38
        },
        {
          "practice": "Use URLSearchParams for query string building",
          "problem": "Issue #38: Complex query parameters with optional filters",
          "solution": "const params = new URLSearchParams(); if (filters?.event_type) params.append('event_type', ...)",
          "validation": "Test with complex filter combinations",
          "first_seen": 38
        },
        {
          "practice": "Import types from '../types' consistently",
          "problem": "Issue #38: Type imports scattered across files",
          "solution": "Centralize type definitions in types/ directory, import consistently",
          "validation": "Search for type definitions before creating new ones",
          "first_seen": 38
        },
        {
          "practice": "Check existing types before creating new ones",
          "problem": "Issue #38: Almost created duplicate workflow types",
          "solution": "grep for existing types (WorkflowState, AuditEventType) before implementing",
          "validation": "Search codebase: grep -r 'interface WorkflowState' client/src/",
          "first_seen": 38
        }
      ]
    },
    "pre_pr_validation": {
      "priority": "critical",
      "learnings": [
        {
          "practice": "Always run full test suite before PR creation",
          "problem": "Issues #59 and #38: Catch errors early to avoid CI failures",
          "solution": "npm test -- --run (for client) or pytest (for backend)",
          "validation": "All tests must pass locally before pushing",
          "command": "cd client && npm test -- --run"
        },
        {
          "practice": "Run build to catch TypeScript errors",
          "problem": "Issue #59: Build errors not caught by tests alone",
          "solution": "npm run build (client) or python -m mypy (backend)",
          "validation": "Build must complete without errors",
          "command": "cd client && npm run build"
        },
        {
          "practice": "Run lint to catch style and import issues",
          "problem": "Issue #59: Unused imports and type-only import violations",
          "solution": "npm run lint (client) or python -m flake8 (backend)",
          "validation": "Lint must pass with no errors (warnings acceptable if pre-existing)",
          "command": "cd client && npm run lint"
        },
        {
          "practice": "Validate in correct working directory for multi-repo",
          "problem": "Backend and client have separate validation requirements",
          "solution": "Client: cd _external/AI-Agent-Framework-Client && npm run lint/test/build",
          "validation": "Run all three validations in sequence for client changes",
          "first_seen": 59
        }
      ]
    },
    "infrastructure_checking": {
      "priority": "medium",
      "learnings": [
        {
          "practice": "Check for existing infrastructure before implementing",
          "problem": "Issue #38: Could have duplicated existing apiClient patterns",
          "solution": "Review existing implementations (RAID methods, workflow types) before coding",
          "validation": "grep for similar functionality, check imports in existing files",
          "first_seen": 38
        },
        {
          "practice": "Follow established patterns in the repo",
          "problem": "Issue #38: Initial test approach didn't match existing patterns",
          "solution": "Look at similar files (raidApiClient.test.tsx) for patterns to follow",
          "validation": "Consistency check: does new code match existing style?",
          "first_seen": 38
        },
        {
          "practice": "Check dependencies between issues",
          "problem": "Issue #38: Depended on API client (#1) and workflow types (#14)",
          "solution": "Verify dependencies exist before starting (apiClient.ts, workflow.ts)",
          "validation": "grep for required files and exports",
          "first_seen": 38
        }
      ]
    },
    "efficiency_patterns": {
      "priority": "medium",
      "learnings": [
        {
          "practice": "Issue #38 was clean due to Issue #59 learnings",
          "problem": "Issue #59 had multiple PR template and TypeScript errors",
          "solution": "Issue #38 avoided these by following established patterns from #59",
          "validation": "Compare PR #84 (clean) vs PRs #80-83 (multiple corrections)",
          "metric": "Issue #38: 1 PR, no corrections. Issue #59: 4 PRs, multiple template/type fixes"
        },
        {
          "practice": "Front-load validation before PR creation",
          "problem": "CI failures waste time and create rework",
          "solution": "Run all validations locally: test → build → lint → PR template check",
          "validation": "Zero CI failures on PR #84 (Issue #38) after applying learnings",
          "first_seen": 38
        }
      ]
    }
  },
  "checklists": {
    "before_pr_creation": [
      "Run full test suite: npm test -- --run (client) or pytest (backend)",
      "Run build: npm run build (client)",
      "Run lint: npm run lint (client) or python -m flake8 apps/api/ (backend)",
      "Check PR template: grep for required sections in .github/pull_request_template.md",
      "Format evidence inline: 'Build ✓ N modules. Tests: X/X. Lint: Clean'",
      "Verify cross-repo impact line: '- Related repos/services impacted:'",
      "Check for unused imports: npm run lint flags these",
      "Verify type-only imports: use 'import type' where appropriate",
      "Review RefObject types: must allow null with strictNullChecks",
      "Check existing patterns: review similar implementations before coding"
    ],
    "on_ci_failure": [
      "Get PR checks status: env GH_PAGER=cat PAGER=cat gh pr checks <PR>",
      "Get failed logs: env GH_PAGER=cat PAGER=cat gh run view <RUN_ID> --log-failed",
      "For PR template issues: update body via REST (gh api -X PATCH), trigger CI rerun (empty commit)",
      "For type errors: check strictNullChecks, verbatimModuleSyntax, unused imports",
      "For test failures: verify mock return types match actual signatures"
    ],
    "multi_repo_coordination": [
      "Identify if fix requires backend, client, or both repos",
      "Plan per-repo validation in correct working directory",
      "Client: cd _external/AI-Agent-Framework-Client && npm run lint && npm test -- --run && npm run build",
      "Backend: source .venv/bin/activate && python -m flake8 apps/api/ && pytest",
      "Update PR template cross-repo impact section with specific repos/services"
    ]
  },
  "anti_patterns": {
    "avoid": [
      "Creating mock axios instances instead of using vi.spyOn on existing apiClient",
      "Using code blocks (```) for evidence in PR descriptions",
      "Manual {current: null} objects instead of React.createRef()",
      "Implementing before checking existing types/services",
      "Pushing without running local validation (test/build/lint)",
      "Using 'any' types to bypass TypeScript errors",
      "Modifying PR body with gh pr edit (use REST API instead)",
      "Assuming CI will catch errors (always validate locally first)"
    ]
  },
  "metrics": {
    "issue_59": {
      "prs": 4,
      "ci_corrections": "multiple",
      "template_fixes": 2,
      "type_fixes": 5,
      "test_fixes": 3,
      "total_tests_added": 80
    },
    "issue_38": {
      "prs": 1,
      "ci_corrections": 0,
      "template_fixes": 0,
      "type_fixes": 0,
      "test_fixes": 0,
      "total_tests_added": 15,
      "notes": "Clean implementation due to Issue #59 learnings"
    }
  }
}
